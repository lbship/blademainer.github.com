<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="blademainer"><link rel="icon" href="/hexo.png"><title>blademainer</title><meta name="description"><link rel="alternate" type="application/rss+xml" title="blademainer" href="/atom.xml"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">
</head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#main-navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">blademainer</a></div><div id="main-navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/archives">Archive</a></li><li><a href="https://github.com/blademainer/blademainer.github.com">Github</a></li><li><a href="/about/">About</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img src="/hexo.png" class="avatar-img"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>最终版解决方案：json循环问题（使用javassist增强）：Spring MVC中使用jackson的MixInAnnotations方法动态过滤JSON字段</h1><p class="post-meta">Posted on Oct 14 2015 · <a href="/tags/java/" class="tag post-meta">java</a> · <a href="/tags/javassist/" class="tag post-meta">javassist</a> · <a href="/tags/spring-mvc/" class="tag post-meta">spring-mvc</a> · <a href="/tags/jackson/" class="tag post-meta">jackson</a> · <a href="/tags/循环/" class="tag post-meta">循环</a> · <a href="/tags/springmvc/" class="tag post-meta">springmvc</a> · <a href="/tags/spring/" class="tag post-meta">spring</a> · <a href="/tags/json/" class="tag post-meta">json</a></p></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role="main" class="blog-post"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>项目使用SpringMVC框架，并用jackson库处理JSON和POJO的转换。在POJO转化成JSON时，有些属性我们不需要输出或者有些属性循环引用会造成无法输出。</p>
<ul>
<li>例如：实体User其中包括用户名、密码、邮箱等，但是我们在输出用户信息不希望输出密码、邮箱信息;</li>
<li>例如：实体user和department是多对一的关系，user内保存着department的信息，那么json输出时会导致这两个实体数据的循环输出;</li>
</ul>
<p>jackson默认可以使用JsonIgnoreProperties接口来定义要过滤的属性,然后使用<code>ObjectMapper#addMixInAnnotations</code>来设置对应实体对应的JsonIgnoreProperties接口,这样就能达到过滤的目的。可是这样很不爽,因为如果你对n个实体对应有m种过滤需求就至少要建n*m个JsonIgnoreProperties接口。</p>
<a id="more"></a>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="主要逻辑如下图"><a href="#主要逻辑如下图" class="headerlink" title="主要逻辑如下图"></a>主要逻辑如下图</h2><p><img src="/images/post/jackson-logic.jpg"></p>
<h2 id="大致处理流程"><a href="#大致处理流程" class="headerlink" title="大致处理流程:"></a>大致处理流程:</h2><ul>
<li>使用自定义注解controller方法</li>
<li>然后定义aop捕获所有controller方法</li>
<li>当aop捕获到controller方法时调用JavassistFilterPropertyHandler#filterProperties方法</li>
<li>filterProperties读取注解并根据自定义注解使用javassist创建JsonIgnoreProperties临时实现类(同时缓存到map内,下次可直接取出)并存入当前线程内(ThreadJacksonMixInHolder, 使用threadlocal实现),</li>
<li>在springmvc输出json的类内自定义ObjectMapper, 从当前线程内取出JsonIgnoreProperties临时类, 调用ObjectMapper# addMixInAnnotations使之起效</li>
<li>最后使用ObjectMapper输出</li>
</ul>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h1><h2 id="定义aop-用来捕获springmvc的controller方法"><a href="#定义aop-用来捕获springmvc的controller方法" class="headerlink" title="定义aop, 用来捕获springmvc的controller方法"></a>定义aop, 用来捕获springmvc的controller方法</h2><pre><code class="java">package com.xiongyingqi.json.filter.aop;

import com.xiongyingqi.jackson.FilterPropertyHandler;
import com.xiongyingqi.jackson.impl.JavassistFilterPropertyHandler;
import org.apache.log4j.Logger;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;

import java.lang.reflect.Method;

/**
 * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt;
 * @version 2013-9-27 下午5:41:12
 */
@Aspect
public class IgnorePropertyAspect {
    public static final Logger LOGGER = Logger.getLogger(IgnorePropertyAspect.class);

    @Pointcut(&quot;execution(* com.kingray.web.*.*(..))&quot;)
    private void anyMethod() {

    }

    @Around(&quot;anyMethod()&quot;)
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        Object returnVal = pjp.proceed(); // 返回源结果
        try {
            FilterPropertyHandler filterPropertyHandler = new JavassistFilterPropertyHandler(true);
            Method method = ((MethodSignature) pjp.getSignature()).getMethod();
            returnVal = filterPropertyHandler.filterProperties(method, returnVal);
        } catch (Exception e) {
            LOGGER.error(e);
            e.printStackTrace();
        }

        return returnVal;
    }

    @AfterThrowing(pointcut = &quot;anyMethod()&quot;, throwing = &quot;e&quot;)
    public void doAfterThrowing(Exception e) {
        System.out.println(&quot; -------- AfterThrowing -------- &quot;);
    }
}
</code></pre>
<h2 id="spring配置"><a href="#spring配置" class="headerlink" title="spring配置"></a>spring配置</h2><pre><code class="xml">&lt;!-- 启动mvc对aop的支持,使用aspectj代理 --&gt;
&lt;aop:aspectj-autoproxyproxy-target-class=&quot;true&quot; /&gt;
&lt;beanid=&quot;ignorePropertyAspect&quot; class=&quot;com.xiongyingqi.json.filter.aop.IgnorePropertyAspect&quot;&gt;&lt;/bean&gt;
</code></pre>
<h2 id="配置spring-mvc的messageconverter"><a href="#配置spring-mvc的messageconverter" class="headerlink" title="配置spring-mvc的messageconverter"></a>配置spring-mvc的messageconverter</h2><pre><code class="xml">    &lt;bean
        class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;
        &lt;property name=&quot;cacheSeconds&quot; value=&quot;0&quot; /&gt;
        &lt;!--日期格式转换 --&gt;
        &lt;property name=&quot;webBindingInitializer&quot;&gt;
            &lt;bean class=&quot;com.kingray.spring.http.convert.DateConverter&quot; /&gt;
        &lt;/property&gt;
        &lt;property name=&quot;messageConverters&quot;&gt;
            &lt;list&gt;
                &lt;bean
                    class=&quot;com.xiongyingqi.spring.http.convert.json.Jackson2HttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;com.xiongyingqi.spring.http.convert.json.JacksonHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.BufferedImageHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.ResourceHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean class=&quot;org.springframework.http.converter.FormHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.feed.AtomFeedHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.feed.RssChannelHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.xml.SourceHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.ByteArrayHttpMessageConverter&quot;&gt;
                &lt;/bean&gt;
            &lt;/list&gt;
        &lt;/property&gt;

    &lt;/bean&gt;
</code></pre>
<h2 id="重写spring的MappingJackson2HttpMessageConverter类-这样输出的json内容就能自定义"><a href="#重写spring的MappingJackson2HttpMessageConverter类-这样输出的json内容就能自定义" class="headerlink" title="重写spring的MappingJackson2HttpMessageConverter类,这样输出的json内容就能自定义"></a>重写spring的MappingJackson2HttpMessageConverter类,这样输出的json内容就能自定义</h2><pre><code class="java">
package com.xiongyingqi.spring.http.convert.json;

import java.io.IOException;

import com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;

import com.fasterxml.jackson.core.JsonEncoding;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

/**
 * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt;
 * @version 2013-9-27 下午4:05:46
 */
public class Jackson2HttpMessageConverter extends MappingJackson2HttpMessageConverter {
    private ObjectMapper objectMapper = new ObjectMapper();
    private boolean prefixJson = false;


    /**
     * &lt;br&gt;
     * 2013-9-27 下午4:10:28
     *
     * @see org.springframework.http.converter.json.MappingJacksonHttpMessageConverter#writeInternal(Object,
     * org.springframework.http.HttpOutputMessage)
     */
    @Override
    protected void writeInternal(Object object, HttpOutputMessage outputMessage)
            throws IOException, HttpMessageNotWritableException {
        // super.writeInternal(object, outputMessage);

        // 判断是否需要重写objectMapper
        ObjectMapper objectMapper = this.objectMapper;// 本地化ObjectMapper，防止方法级别的ObjectMapper改变全局ObjectMapper
        if (ThreadJacksonMixInHolder.isContainsMixIn()) {
            objectMapper = ThreadJacksonMixInHolder.builderMapper();
        }

        JsonEncoding encoding = getJsonEncoding(outputMessage.getHeaders().getContentType());
        JsonGenerator jsonGenerator = objectMapper.getFactory().createGenerator(
                outputMessage.getBody(), encoding);

        // A workaround for JsonGenerators not applying serialization features
        // https://github.com/FasterXML/jackson-databind/issues/12
        if (objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
            jsonGenerator.useDefaultPrettyPrinter();
        }

        try {
            if (this.prefixJson) {
                jsonGenerator.writeRaw(&quot;{} &amp;&amp; &quot;);
            }
            objectMapper.writeValue(jsonGenerator, object);
        } catch (JsonProcessingException ex) {
            throw new HttpMessageNotWritableException(&quot;Could not write JSON: &quot; + ex.getMessage(),
                    ex);
        }
        // JsonEncoding encoding =
        // getJsonEncoding(outputMessage.getHeaders().getContentType());
        // JsonGenerator jsonGenerator =
        // this.objectMapper.getJsonFactory().createJsonGenerator(outputMessage.getBody(),
        // encoding);
        //
        // // A workaround for JsonGenerators not applying serialization
        // features
        // // https://github.com/FasterXML/jackson-databind/issues/12
        // if (this.objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT))
        // {
        // jsonGenerator.useDefaultPrettyPrinter();
        // }
        //
        // try {
        // if (this.prefixJson) {
        // jsonGenerator.writeRaw(&quot;{} &amp;&amp; &quot;);
        // }
        // this.objectMapper.writeValue(jsonGenerator, object);
        // }
        // catch (JsonProcessingException ex) {
        // throw new HttpMessageNotWritableException(&quot;Could not write JSON: &quot; +
        // ex.getMessage(), ex);
        // }
    }

    public boolean isPrefixJson() {
        return prefixJson;
    }

    public void setPrefixJson(boolean prefixJson) {
        this.prefixJson = prefixJson;
    }

}
</code></pre>
<h2 id="在方法上注解"><a href="#在方法上注解" class="headerlink" title="在方法上注解"></a>在方法上注解</h2><h3 id="Controller方法的示例，yxResourceSelfRelationsForSuperiorResourceId是YxResource内要过滤的属性"><a href="#Controller方法的示例，yxResourceSelfRelationsForSuperiorResourceId是YxResource内要过滤的属性" class="headerlink" title="Controller方法的示例，yxResourceSelfRelationsForSuperiorResourceId是YxResource内要过滤的属性:"></a>Controller方法的示例，yxResourceSelfRelationsForSuperiorResourceId是YxResource内要过滤的属性:</h3><pre><code class="java">
    @IgnoreProperties(value= {
           @IgnoreProperty(pojo = YxResource.class, name = {
                  &quot;yxResourceSelfRelationsForSuperiorResourceId&quot;})})
   @RequestMapping(value = &quot;/{resourceId}&quot;, method = RequestMethod.GET)
   @ResponseBody
   public Object getResourceByResourceId(@PathVariable Integer resourceId) {
       YxResource resource = resourceService.getResource(resourceId);
       return resource;
    }
</code></pre>
<h1 id="主要类说明"><a href="#主要类说明" class="headerlink" title="主要类说明"></a>主要类说明</h1><h2 id="自定义注解类：这些类是用于注解实体类输出json时要注解过滤的属性"><a href="#自定义注解类：这些类是用于注解实体类输出json时要注解过滤的属性" class="headerlink" title="自定义注解类：这些类是用于注解实体类输出json时要注解过滤的属性"></a>自定义注解类：这些类是用于注解实体类输出json时要注解过滤的属性</h2><h3 id="IgnoreProperties-java-用于同时注解IgnoreProperty和AllowProperty"><a href="#IgnoreProperties-java-用于同时注解IgnoreProperty和AllowProperty" class="headerlink" title="IgnoreProperties.java 用于同时注解IgnoreProperty和AllowProperty"></a><code>IgnoreProperties.java</code> 用于同时注解<code>IgnoreProperty</code>和<code>AllowProperty</code></h3><pre><code class="java">
package com.xiongyingqi.jackson.annotation;

import java.lang.annotation.*;

/**
 * json属性过滤注解，对于同一个pojo来说 @AllowProperty 是与 @IgnoreProperty 是冲突的，如果这两个注解注解了&lt;br&gt;
 * 例如以下代码YxResource实体只会显示resourceName和resourceDescribe属性
 * &lt;p/&gt;
 * &lt;pre&gt;
 * @IgnoreProperties(
 *     value = {
 *         @IgnoreProperty(
 *             pojo = YxResource.class,
 *             name = {
 *                 &quot;yxResourceDataRelations&quot;,
 *                 &quot;yxResourceSelfRelationsForSublevelResourceId&quot;,
 *                 &quot;yxPermisionResourceRelations&quot; }),
 *         @IgnoreProperty(
 *             pojo = YxResourceSelfRelation.class,
 *             name = {
 *                 &quot;yxResourceBySuperiorResourceId&quot;,
 *                 &quot;id&quot; })
 *    },
 *     allow = {
 *     @AllowProperty(
 *             pojo = YxResource.class,
 *             name = { &quot;&lt;b&gt;&lt;i&gt;resourceName&lt;/i&gt;&lt;/b&gt;&quot; }) })
 *     @AllowProperty(
 *             pojo = YxResource.class,
 *             name = { &quot;&lt;b&gt;&lt;i&gt;resourceDescribe&lt;/i&gt;&lt;/b&gt;&quot; })
 * &lt;/pre&gt;
 * &lt;p/&gt;
 * &lt;p/&gt;
 * 但是，对于同一个pojo的同一属性来说@AllowProperty是与@IgnoreProperty则会按照@IgnoreProperty过滤的属性名过滤
 * 例如以下代码YxResource实体不会显示resourceName属性的值
 * &lt;p/&gt;
 * &lt;pre&gt;
 * @IgnoreProperties(
 *     value = {
 *     @IgnoreProperty(
 *             pojo = YxResource.class,
 *             name = { &quot;&lt;b&gt;&lt;i&gt;resourceName&lt;/i&gt;&lt;/b&gt;&quot;,
 *                 &quot;yxResourceDataRelations&quot;,
 *                 &quot;yxResourceSelfRelationsForSublevelResourceId&quot;,
 *                 &quot;yxPermisionResourceRelations&quot; }),
 *     @IgnoreProperty(
 *             pojo = YxResourceSelfRelation.class,
 *             name = {
 *                 &quot;yxResourceBySuperiorResourceId&quot;,
 *                 &quot;id&quot; })
 *    },
 *     allow = {
 *     @AllowProperty(
 *             pojo = YxResource.class,
 *             name = { &quot;&lt;b&gt;&lt;i&gt;resourceName&lt;/i&gt;&lt;/b&gt;&quot; }) })
 * &lt;/pre&gt;
 *
 * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt;
 * @version 2013-9-27 下午4:18:39
 */
@Documented
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface IgnoreProperties {
    /**
     * 要过滤的属性
     *
     * @return
     */
    IgnoreProperty[] value() default @IgnoreProperty(pojo = Object.class, name = &quot;&quot;);

    /**
     * 允许的属性
     *
     * @return
     */
    AllowProperty[] allow() default @AllowProperty(pojo = Object.class, name = &quot;&quot;);
}
</code></pre>
<h3 id="IgnoreProperty-java：过滤指定对象内的指定字段名"><a href="#IgnoreProperty-java：过滤指定对象内的指定字段名" class="headerlink" title="IgnoreProperty.java：过滤指定对象内的指定字段名"></a><code>IgnoreProperty.java</code>：过滤指定对象内的指定字段名</h3><pre><code class="java">
package com.xiongyingqi.jackson.annotation;

import java.lang.annotation.*;

/**
 * 用于注解json过滤pojo内的属性，其他的属性都会被序列化成字符串
 *
 * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt;
 * @version 2013-9-27 下午4:24:33
 */
@Documented
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface IgnoreProperty {
    /**
     * 要忽略字段的POJO &lt;br&gt;
     * 2013-9-27 下午4:27:08
     *
     * @return
     */
    Class&lt;?&gt; pojo();

    /**
     * 要忽略的字段名 &lt;br&gt;
     * 2013-9-27 下午4:27:12
     *
     * @return
     */
    String[] name();

    /**
     * 字段名，无论是哪种 &lt;br&gt;
     * 2013-9-27 下午4:27:15
     *
     * @return
     */
    //    String value() default &quot;&quot;;

    /**
     * 最大迭代层次&lt;br&gt;
     * 当注解了pojo和name值时，该值表示遍历bean属性的最大曾次数，此注解一般用于自关联的bean类，
     * 如果循环层次大于等于maxLevel时则不再读取属性&lt;br&gt;
     * 如果maxIterationLevel为0，则不限制迭代层次&lt;br&gt;
     * 如果maxIterationLevel为1，则迭代读取属性一次&lt;br&gt;
     * 2013-10-21 下午2:16:26
     *
     * @return
     */
    //    int maxIterationLevel() default 0;
}
</code></pre>
<h3 id="AllowProperty-java：注解实体类允许的字段"><a href="#AllowProperty-java：注解实体类允许的字段" class="headerlink" title="AllowProperty.java：注解实体类允许的字段"></a><code>AllowProperty.java</code>：注解实体类允许的字段</h3><pre><code class="java">
package com.xiongyingqi.jackson.annotation;

import java.lang.annotation.*;

/**
 * 只允许pojo内的属性序列化成json，对于同一个pojo该注解是与IgnoreProperty是冲突的&lt;br&gt;
 *
 * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt;
 * @version 2013-10-30 下午3:57:35
 */
@Documented
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface AllowProperty {
    /**
     * 目标POJO &lt;br&gt;
     * 2013-9-27 下午4:27:08
     *
     * @return
     */
    Class&lt;?&gt; pojo();

    /**
     * 允许序列化的属性名 &lt;br&gt;
     * 2013-9-27 下午4:27:12
     *
     * @return
     */
    String[] name();
}
</code></pre>
<h2 id="核心处理类，用于处理自定义注解并将生成的类存入当前线程"><a href="#核心处理类，用于处理自定义注解并将生成的类存入当前线程" class="headerlink" title="核心处理类，用于处理自定义注解并将生成的类存入当前线程"></a>核心处理类，用于处理自定义注解并将生成的类存入当前线程</h2><pre><code class="java">package com.xiongyingqi.jackson.impl;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonEncoding;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.xiongyingqi.jackson.FilterPropertyHandler;
import com.xiongyingqi.jackson.annotation.AllowProperty;
import com.xiongyingqi.jackson.annotation.IgnoreProperties;
import com.xiongyingqi.jackson.annotation.IgnoreProperty;
import com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder;
import com.xiongyingqi.util.EntityHelper;
import com.xiongyingqi.util.StringHelper;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.bytecode.AnnotationsAttribute;
import javassist.bytecode.ClassFile;
import javassist.bytecode.ConstPool;
import javassist.bytecode.annotation.*;
import org.apache.log4j.Logger;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.ResponseBody;

import java.lang.reflect.Method;
import java.nio.charset.Charset;
import java.util.*;
import java.util.Map.Entry;

//@IgnoreProperty(pojo = YxUserRoleRelation.class, name = { &quot;id&quot;, &quot;yxUser&quot; })

/**
 * 使用代理来创建jackson的MixInAnnotation注解接口&lt;br&gt;
 * 如果使用本实现方法，一定要配置在web.xml中配置过滤器WebContextFilter，否则无法输出json到客户端
 *
 * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt;
 * @version 2013-10-25 下午2:31:21
 */
public class JavassistFilterPropertyHandler implements FilterPropertyHandler {

    public static final Logger LOGGER = Logger.getLogger(JavassistFilterPropertyHandler.class);

    /**
     * 注解的方法对应生成的代理类映射表
     */
    private static Map&lt;Method, Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; proxyMethodMap = new HashMap&lt;Method, Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt;();

    /**
     * String数组的hashCode与生成的对应的代理类的映射表
     */
    private static Map&lt;Integer, Class&lt;?&gt;&gt; proxyMixInAnnotationMap = new HashMap&lt;Integer, Class&lt;?&gt;&gt;();

    private static String[] globalIgnoreProperties = new String[]{&quot;hibernateLazyInitializer&quot;,
            &quot;handler&quot; };

    /**
     * 如果是标注的SpringMVC中的Controller方法，则应判断是否注解了@ResponseBody
     */
    private boolean isResponseBodyAnnotation;
    /**
     * 创建代理接口的唯一值索引
     */
    private static int proxyIndex;

    public JavassistFilterPropertyHandler() {
    }

    public JavassistFilterPropertyHandler(String[] globalIgnoreProperties) {
        JavassistFilterPropertyHandler.globalIgnoreProperties = globalIgnoreProperties;
    }

    /**
     * @param isResponseBodyAnnotation 如果是标注的SpringMVC中的Controller方法，则应判断是否注解了@ResponseBody
     */
    public JavassistFilterPropertyHandler(boolean isResponseBodyAnnotation) {
        this.isResponseBodyAnnotation = isResponseBodyAnnotation;
    }

    /**
     * &lt;br&gt;
     * 2013-10-28 上午11:11:24
     *
     * @param collection
     * @param names
     * @return
     */
    private Collection&lt;String&gt; checkAndPutToCollection(Collection&lt;String&gt; collection, String[] names) {
        if (collection == null) {
            collection = new HashSet&lt;String&gt;();
        }
        Collections.addAll(collection, names);
        return collection;
    }

    private Collection&lt;String&gt; putGlobalIgnoreProperties(Collection&lt;String&gt; collection) {
        if (globalIgnoreProperties != null) {
            if (collection == null) {
                collection = new HashSet&lt;String&gt;();
            }
            for (int i = 0; i &lt; globalIgnoreProperties.length; i++) {
                String name = globalIgnoreProperties[i];
                collection.add(name);
            }
        }
        return collection;
    }

    /**
     * 处理IgnoreProperties注解 &lt;br&gt;
     * 2013-10-30 下午6:15:41
     *
     * @param properties
     * @param pojoAndNamesMap
     */
    private void processIgnorePropertiesAnnotation(IgnoreProperties properties,
                                                   Map&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; pojoAndNamesMap) {
        IgnoreProperty[] values = properties.value();

        AllowProperty[] allowProperties = properties.allow();

        if (allowProperties != null) {
            for (AllowProperty allowProperty : allowProperties) {
                processAllowPropertyAnnotation(allowProperty, pojoAndNamesMap);
            }
        }

        if (values != null) {
            for (IgnoreProperty property : values) {
                processIgnorePropertyAnnotation(property, pojoAndNamesMap);
            }
        }

    }

    /**
     * 处理IgnoreProperty注解 &lt;br&gt;
     * 2013-10-30 下午6:16:08
     *
     * @param property
     * @param pojoAndNamesMap
     */
    private void processIgnorePropertyAnnotation(IgnoreProperty property,
                                                 Map&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; pojoAndNamesMap) {
        String[] names = property.name();
        Class&lt;?&gt; pojoClass = property.pojo();
        // Class&lt;?&gt; proxyAnnotationInterface = createMixInAnnotation(names);//
        // 根据注解创建代理接口

        Collection&lt;String&gt; nameCollection = pojoAndNamesMap.get(pojoClass);
        nameCollection = checkAndPutToCollection(nameCollection, names);
        pojoAndNamesMap.put(pojoClass, nameCollection);
    }

    /**
     * 处理AllowProperty注解 &lt;br&gt;
     * 2013-10-30 下午6:16:08
     *
     * @param property
     * @param pojoAndNamesMap
     */
    private void processAllowPropertyAnnotation(AllowProperty property,
                                                Map&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; pojoAndNamesMap) {
        String[] allowNames = property.name();
        Class&lt;?&gt; pojoClass = property.pojo();

        Collection&lt;String&gt; ignoreProperties = EntityHelper
                .getUnstaticClassFieldNameCollection(pojoClass);

        Collection&lt;String&gt; allowNameCollection = new ArrayList&lt;String&gt;();
        Collections.addAll(allowNameCollection, allowNames);

        Collection&lt;String&gt; nameCollection = pojoAndNamesMap.get(pojoClass);
        if (nameCollection != null) {
            nameCollection.removeAll(allowNameCollection);
        } else {
            ignoreProperties.removeAll(allowNameCollection);
            nameCollection = ignoreProperties;
        }
        pojoAndNamesMap.put(pojoClass, nameCollection);
    }

    /**
     * 根据方法获取过滤映射表 &lt;br&gt;
     * 2013-10-25 下午2:47:34
     *
     * @param method 注解了 @IgnoreProperties 或 @IgnoreProperty 的方法（所在的类）
     * @return Map&lt;Class&lt;?&gt;, Collection&lt;Class&lt;?&gt;&gt;&gt; pojo与其属性的映射表
     */
    public Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; getProxyMixInAnnotation(Method method) {
        if (isResponseBodyAnnotation &amp;&amp; !method.isAnnotationPresent(ResponseBody.class)) {
            return null;
        }
        Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map = proxyMethodMap.get(method);// 从缓存中查找是否存在

        if (map != null &amp;&amp; map.entrySet().size() &gt; 0) {// 如果已经读取该方法的注解信息，则从缓存中读取
            return map;
        } else {
            map = new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;();
        }

        Class&lt;?&gt; clazzOfMethodIn = method.getDeclaringClass();// 方法所在的class

        Map&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; pojoAndNamesMap = new HashMap&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt;();

        IgnoreProperties classIgnoreProperties = clazzOfMethodIn
                .getAnnotation(IgnoreProperties.class);
        IgnoreProperty classIgnoreProperty = clazzOfMethodIn.getAnnotation(IgnoreProperty.class);
        AllowProperty classAllowProperty = clazzOfMethodIn.getAnnotation(AllowProperty.class);

        IgnoreProperties ignoreProperties = method.getAnnotation(IgnoreProperties.class);
        IgnoreProperty ignoreProperty = method.getAnnotation(IgnoreProperty.class);
        AllowProperty allowProperty = method.getAnnotation(AllowProperty.class);

        if (allowProperty != null) {// 方法上的AllowProperty注解
            processAllowPropertyAnnotation(allowProperty, pojoAndNamesMap);
        }
        if (classAllowProperty != null) {
            processAllowPropertyAnnotation(classAllowProperty, pojoAndNamesMap);
        }

        if (classIgnoreProperties != null) {// 类上的IgnoreProperties注解
            processIgnorePropertiesAnnotation(classIgnoreProperties, pojoAndNamesMap);
        }
        if (classIgnoreProperty != null) {// 类上的IgnoreProperty注解
            processIgnorePropertyAnnotation(classIgnoreProperty, pojoAndNamesMap);
        }

        if (ignoreProperties != null) {// 方法上的IgnoreProperties注解
            processIgnorePropertiesAnnotation(ignoreProperties, pojoAndNamesMap);
        }
        if (ignoreProperty != null) {// 方法上的IgnoreProperties注解
            processIgnorePropertyAnnotation(ignoreProperty, pojoAndNamesMap);
        }

        Set&lt;Entry&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt;&gt; entries = pojoAndNamesMap.entrySet();
        for (Iterator&lt;Entry&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt;&gt; iterator = entries.iterator(); iterator
                .hasNext(); ) {
            Entry&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; entry = (Entry&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt;) iterator
                    .next();
            Collection&lt;String&gt; nameCollection = entry.getValue();
            nameCollection = putGlobalIgnoreProperties(nameCollection);// 将全局过滤字段放入集合内
            String[] names = nameCollection.toArray(new String[]{});

            // EntityHelper.print(entry.getKey());
            // for (int i = 0; i &lt; names.length; i++) {
            // String name = names[i];
            // EntityHelper.print(name);
            // }
            Class&lt;?&gt; clazz = createMixInAnnotation(names);

            map.put(entry.getKey(), clazz);
        }

        proxyMethodMap.put(method, map);
        return map;
    }

    /**
     * 创建jackson的代理注解接口类 &lt;br&gt;
     * 2013-10-25 上午11:59:50
     *
     * @param names 要生成的字段
     * @return 代理接口类
     */
    private Class&lt;?&gt; createMixInAnnotation(String[] names) {
        Class&lt;?&gt; clazz = null;
        clazz = proxyMixInAnnotationMap.get(StringHelper.hashCodeOfStringArray(names));
        if (clazz != null) {
            return clazz;
        }

        ClassPool pool = ClassPool.getDefault();

        // 创建代理接口
        CtClass cc = pool.makeInterface(&quot;ProxyMixInAnnotation&quot; + System.currentTimeMillis()
                + proxyIndex++);

        ClassFile ccFile = cc.getClassFile();
        ConstPool constpool = ccFile.getConstPool();

        // create the annotation
        AnnotationsAttribute attr = new AnnotationsAttribute(constpool,
                AnnotationsAttribute.visibleTag);
        // 创建JsonIgnoreProperties注解
        Annotation jsonIgnorePropertiesAnnotation = new Annotation(
                JsonIgnoreProperties.class.getName(), constpool);

        BooleanMemberValue ignoreUnknownMemberValue = new BooleanMemberValue(false, constpool);

        ArrayMemberValue arrayMemberValue = new ArrayMemberValue(constpool);// value的数组成员

        Collection&lt;MemberValue&gt; memberValues = new HashSet&lt;MemberValue&gt;();
        for (int i = 0; i &lt; names.length; i++) {
            String name = names[i];
            StringMemberValue memberValue = new StringMemberValue(constpool);// 将name值设入注解内
            memberValue.setValue(name);
            memberValues.add(memberValue);
        }
        arrayMemberValue.setValue(memberValues.toArray(new MemberValue[]{}));

        jsonIgnorePropertiesAnnotation.addMemberValue(&quot;value&quot;, arrayMemberValue);
        jsonIgnorePropertiesAnnotation.addMemberValue(&quot;ignoreUnknown&quot;, ignoreUnknownMemberValue);

        attr.addAnnotation(jsonIgnorePropertiesAnnotation);
        ccFile.addAttribute(attr);

        // generate the class
        try {
            clazz = cc.toClass();
            proxyMixInAnnotationMap.put(StringHelper.hashCodeOfStringArray(names), clazz);
            // JsonIgnoreProperties ignoreProperties = (JsonIgnoreProperties)
            // clazz
            // .getAnnotation(JsonIgnoreProperties.class);

            // EntityHelper.print(ignoreProperties);
            //
            // EntityHelper.print(clazz);

            // try {
            // Object instance = clazz.newInstance();
            // EntityHelper.print(instance);
            //
            // } catch (InstantiationException e) {
            // e.printStackTrace();
            // } catch (IllegalAccessException e) {
            // e.printStackTrace();
            // }
        } catch (CannotCompileException e) {
            e.printStackTrace();
        }

        // right
        // mthd.getMethodInfo().addAttribute(attr);

        return clazz;

    }


    @Override
    public Object filterProperties(Method method, Object object) {

        Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map = getProxyMixInAnnotation(method);
        if (map == null || map.entrySet().size() == 0) {// 如果该方法上没有注解，则返回原始对象
            return object;
        }

//        Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; entries = map.entrySet();
//        for (Iterator&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; iterator = entries.iterator(); iterator.hasNext();) {
//            Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; entry = (Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;) iterator.next();
//            //            EntityHelper.print(entry.getKey());
//            Class&lt;?&gt; clazz = entry.getValue();
//            //            EntityHelper.print(clazz.getAnnotation(JsonIgnoreProperties.class));
//        }


//        ObjectMapper mapper = createObjectMapper(map);
        ThreadJacksonMixInHolder.addMixIns(getEntries(map));
//        try {
//            HttpServletResponse response = WebContext.getInstance().getResponse();
//            writeJson(mapper, response, object);
//        } catch (WebContextAlreadyClearedException e) {
//            e.printStackTrace();
//        }

        return object;
    }

    public Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; getEntries(Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map) {
        Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; entries = map.entrySet();
        return entries;
    }

    /**
     * 根据指定的过滤表创建jackson对象 &lt;br&gt;
     * 2013-10-25 下午2:46:43
     *
     * @param map 过滤表
     * @return ObjectMapper
     */
    private ObjectMapper createObjectMapper(Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map) {
        ObjectMapper mapper = new ObjectMapper();
        Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; entries = map.entrySet();
        for (Iterator&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; iterator = entries.iterator(); iterator.hasNext(); ) {
            Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; entry = iterator.next();
            mapper.addMixInAnnotations(entry.getKey(), entry.getValue());
        }
        return mapper;
    }

    /**
     * 根据方法上的注解生成objectMapper
     *
     * @param method
     * @return
     */
    public ObjectMapper createObjectMapper(Method method) {
        return createObjectMapper(getProxyMixInAnnotation(method));
    }

//    /**
//     * 将结果输出到response &lt;br&gt;
//     * 2013-10-25 下午2:28:40
//     *
//     * @param objectMapper
//     * @param response
//     * @param object
//     */
//    private void writeJson(ObjectMapper objectMapper, HttpServletResponse response, Object object) {
//        response.setContentType(&quot;application/json&quot;);
//
//        JsonEncoding encoding = getJsonEncoding(response.getCharacterEncoding());
//        JsonGenerator jsonGenerator = null;
//        try {
//            jsonGenerator = objectMapper.getJsonFactory().createJsonGenerator(
//                    response.getOutputStream(), encoding);
//        } catch (IOException e1) {
//            e1.printStackTrace();
//        }
//
//        // A workaround for JsonGenerators not applying serialization features
//        // https://github.com/FasterXML/jackson-databind/issues/12
//        if (objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
//            jsonGenerator.useDefaultPrettyPrinter();
//        }
//
//        try {
//            objectMapper.writeValue(jsonGenerator, object);
//        } catch (JsonProcessingException ex) {
//            LOGGER.error(ex);
//
//            throw new HttpMessageNotWritableException(&quot;Could not write JSON: &quot; + ex.getMessage(),
//                    ex);
//        } catch (IOException e) {
//            LOGGER.error(e);
//            // e.printStackTrace();
//        }
//
//    }

    /**
     * &lt;br&gt;
     * 2013-10-25 下午12:29:58
     *
     * @param characterEncoding
     * @return
     */
    private JsonEncoding getJsonEncoding(String characterEncoding) {
        for (JsonEncoding encoding : JsonEncoding.values()) {
            if (characterEncoding.equals(encoding.getJavaName())) {
                return encoding;
            }
        }
        return JsonEncoding.UTF8;
    }

    /**
     * Determine the JSON encoding to use for the given content type.
     *
     * @param contentType the media type as requested by the caller
     * @return the JSON encoding to use (never {@code null})
     */
    protected JsonEncoding getJsonEncoding(MediaType contentType) {
        if (contentType != null &amp;&amp; contentType.getCharSet() != null) {
            Charset charset = contentType.getCharSet();
            for (JsonEncoding encoding : JsonEncoding.values()) {
                if (charset.name().equals(encoding.getJavaName())) {
                    return encoding;
                }
            }
        }
        return JsonEncoding.UTF8;
    }

}
</code></pre>
<h2 id="线程持有类，用于在当前线程内保存核心类处理过的自定义注解生成的MixIn注解，并且能提供ObjectMapper的生成"><a href="#线程持有类，用于在当前线程内保存核心类处理过的自定义注解生成的MixIn注解，并且能提供ObjectMapper的生成" class="headerlink" title="线程持有类，用于在当前线程内保存核心类处理过的自定义注解生成的MixIn注解，并且能提供ObjectMapper的生成"></a>线程持有类，用于在当前线程内保存核心类处理过的自定义注解生成的MixIn注解，并且能提供ObjectMapper的生成</h2><pre><code class="java">package com.xiongyingqi.jackson.helper;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * 在当前线程内保存ObjectMapper供Jackson2HttpMessageConverter使用
 * Created by 瑛琪&lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; on 2014/4/1 0001.
 */
public class ThreadJacksonMixInHolder {
    private static ThreadLocal&lt;ThreadJacksonMixInHolder&gt; holderThreadLocal = new ThreadLocal&lt;ThreadJacksonMixInHolder&gt;();
    private Set&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; mixIns;
    private ObjectMapper mapper;
    private org.codehaus.jackson.map.ObjectMapper codehausMapper;

    /**
     * 根据当前MixIn集合生成objectMapper&lt;p&gt;
     * &lt;p/&gt;
     * &lt;b&gt;注意：该方法在返回mapper对象之后调用clear方法，如果再次调用builderMapper()肯定会保存&lt;/b&gt;
     *
     * @return
     */
    public static ObjectMapper builderMapper() {
        ThreadJacksonMixInHolder holder = holderThreadLocal.get();
        if (holder.mapper == null &amp;&amp; isContainsMixIn()) {
            holder.mapper = new ObjectMapper();
            for (Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; mixIn : holder.mixIns) {
                holder.mapper.addMixInAnnotations(mixIn.getKey(), mixIn.getValue());
            }
        }
        clear();// 如果不调用clear可能导致线程内的数据是脏的！
        return holder.mapper;
    }

    /**
     * 根据当前MixIn集合生成objectMapper
     *
     * @return
     */
    public static org.codehaus.jackson.map.ObjectMapper builderCodehausMapper() {
        ThreadJacksonMixInHolder holder = holderThreadLocal.get();
        if (holder.codehausMapper == null &amp;&amp; isContainsMixIn()) {
            holder.codehausMapper = new org.codehaus.jackson.map.ObjectMapper();
            for (Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; mixIn : holder.mixIns) {
                holder.codehausMapper.getDeserializationConfig().addMixInAnnotations(mixIn.getKey(), mixIn.getValue());
                holder.codehausMapper.getSerializationConfig().addMixInAnnotations(mixIn.getKey(), mixIn.getValue());
            }
        }
        clear();// 如果不调用clear可能导致线程内的数据是脏的！
        return holder.codehausMapper;
    }

    /**
     * 清除当前线程内的数据
     */
    public static void clear() {
        holderThreadLocal.set(null);
//        holderThreadLocal.remove();
    }

    /**
     * 设置MixIn集合到线程内，如果线程内已经存在数据，则会先清除
     *
     * @param resetMixIns
     */
    public static void setMixIns(Set&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; resetMixIns) {
        ThreadJacksonMixInHolder holder = holderThreadLocal.get();
        if (holder == null) {
            holder = new ThreadJacksonMixInHolder();
            holderThreadLocal.set(holder);
        }
        holder.mixIns = resetMixIns;
    }

    /**
     * 不同于setMixIns，addMixIns为增加MixIn集合到线程内，即不会清除已经保存的数据
     * &lt;br&gt;2014年4月4日 下午12:08:15
     *
     * @param toAddMixIns
     */
    public static void addMixIns(Set&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; toAddMixIns) {
        ThreadJacksonMixInHolder holder = holderThreadLocal.get();
        if (holder == null) {
            holder = new ThreadJacksonMixInHolder();
            holderThreadLocal.set(holder);
        }
        if (holder.mixIns == null) {
            holder.mixIns = new HashSet&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt;();
        }
        holder.mixIns.addAll(toAddMixIns);
    }

    /**
     * 获取线程内的MixIn集合&lt;p&gt;&lt;/p&gt;
     * &lt;b&gt;注意：为了防止线程执行完毕之后仍然存在有数据，请务必适时调用clear()方法&lt;/b&gt;
     *
     * @return
     * @see com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder#builderMapper()
     * @see com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder#builderCodehausMapper()
     * @see com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder#clear()
     */
    public static Set&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; getMixIns() {
        ThreadJacksonMixInHolder holder = holderThreadLocal.get();
        return holder.mixIns;
    }

    /**
     * 判断当前线程是否存在MixIn集合
     *
     * @return
     */
    public static boolean isContainsMixIn() {
        if (holderThreadLocal.get() == null) {
            return false;
        }
        if (holderThreadLocal.get().mixIns != null &amp;&amp; holderThreadLocal.get().mixIns.size() &gt; 0) {
            return true;
        }
        return false;
    }

}
</code></pre>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><pre><code class="java">package com.xiongyingqi.jackson;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.xiongyingqi.jackson.annotation.IgnoreProperties;
import com.xiongyingqi.jackson.annotation.IgnoreProperty;
import com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder;
import com.xiongyingqi.jackson.impl.JavassistFilterPropertyHandler;
import com.xiongyingqi.jackson.pojo.Group;
import com.xiongyingqi.jackson.pojo.User;
import com.xiongyingqi.util.Assert;
import com.xiongyingqi.util.EntityHelper;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Created by 瑛琪&lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; on 2014/6/4 0004.
 */
public class JsonFilterPropertyTest {

    @IgnoreProperties(@IgnoreProperty(pojo = User.class, name = &quot;id&quot;))
    public Collection&lt;User&gt; listUsers() {
        Group group1 = new Group();
        group1.setId(1);
        group1.setName(&quot;分组1&quot;);

        User user1 = new User();
        user1.setId(1);
        user1.setGroup(group1);
        user1.setName(&quot;用户1&quot;);
        User user2 = new User();
        user2.setId(1);
        user2.setGroup(group1);
        user2.setName(&quot;用户1&quot;);
        User user3 = new User();
        user3.setId(1);
        user3.setName(&quot;用户1&quot;);
        user3.setGroup(group1);


        Group group2 = new Group();
        group2.setId(2);
        group2.setName(&quot;分组2&quot;);

        User user4 = new User();
        user4.setId(4);
        user4.setGroup(group2);
        user4.setName(&quot;用户4&quot;);
        User user5 = new User();
        user5.setId(5);
        user5.setGroup(group2);
        user5.setName(&quot;用户5&quot;);
        User user6 = new User();
        user6.setId(6);
        user6.setName(&quot;用户6&quot;);
        user6.setGroup(group2);

        Collection&lt;User&gt; users = new ArrayList&lt;User&gt;();
        users.add(user1);
        users.add(user2);
        users.add(user3);
        users.add(user4);
        users.add(user5);
        users.add(user6);
        return users;
    }

    @Test
    public void jsonTest() throws NoSuchMethodException, JsonProcessingException {
        FilterPropertyHandler filterPropertyHandler = new JavassistFilterPropertyHandler(false);
        Object object = listUsers();

        object = filterPropertyHandler.filterProperties(JsonFilterPropertyTest.class.getMethod(&quot;listUsers&quot;), object);


        ObjectMapper mapper = ThreadJacksonMixInHolder.builderMapper();
        String json = mapper.writeValueAsString(object);
        EntityHelper.print(json);
        Assert.hasText(json);
    }
}
</code></pre>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><hr>
<pre><code>at com.xiongyingqi.jackson.JsonFilterPropertyTest.jsonTest(JsonFilterPropertyTest.java:80)
String =============== [{&quot;name&quot;:&quot;用户1&quot;,&quot;group&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;分组1&quot;}},{&quot;name&quot;:&quot;用户1&quot;,&quot;group&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;分组1&quot;}},{&quot;name&quot;:&quot;用户1&quot;,&quot;group&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;分组1&quot;}},{&quot;name&quot;:&quot;用户4&quot;,&quot;group&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;分组2&quot;}},{&quot;name&quot;:&quot;用户5&quot;,&quot;group&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;分组2&quot;}},{&quot;name&quot;:&quot;用户6&quot;,&quot;group&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;分组2&quot;}}]
</code></pre><hr>
<h1 id="性能与缺陷"><a href="#性能与缺陷" class="headerlink" title="性能与缺陷"></a>性能与缺陷</h1><ul>
<li>主要是在map内存储了Javassist的临时类，每个注解(IgnoreProperties等)的方法的调用，对应在FilterPropertyHandler会处理一次注解并在内存内产生一个Javassist临时类，但是访问过一次之后该类就会读取map缓存</li>
<li>ThreadJacksonMixInHolder：这个类的原理就是使用ThreadLocal在当前线程内存储处理过的annotation注解，java的容器或框架都是使用了该类，导致的效率问题应该不大</li>
<li>未知的bug</li>
</ul>
<h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><p>其他框架内使用<br>如果不是spring-mvc框架也能使用这些代码来解决，只是必须要修改aop的捕获方法、使用new JavassistFilterPropertyHandler(false)禁用ResponseBody，以及在ObjectMapper输出使用自己定义的输出</p>
<h2 id="源代码地址"><a href="#源代码地址" class="headerlink" title="源代码地址"></a>源代码地址</h2><div class="github-widget" data-repo="blademainer/common_utils"></div>

<h2 id="代码已上传到maven中央库："><a href="#代码已上传到maven中央库：" class="headerlink" title="代码已上传到maven中央库："></a>代码已上传到maven中央库：</h2><p><a href="http://mvnrepository.com/artifact/com.xiongyingqi/common_helper" target="_blank" rel="external">http://mvnrepository.com/artifact/com.xiongyingqi/common_helper</a></p>
<h2 id="Maven-Usage"><a href="#Maven-Usage" class="headerlink" title="Maven Usage:"></a>Maven Usage:</h2><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.xiongyingqi&lt;/groupId&gt;
    &lt;artifactId&gt;common_helper&lt;/artifactId&gt;
    &lt;version&gt;${common_utils.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</article><ul class="pager blog-pager"><li class="previous"><a href="/2015/10/30/scala-object-reflect-get/" data-toggle="tooltip" data-placement="top" title="scala根据Class获取单例（孤立）对象">← Previous Post</a></li><li class="next"><a href="/2014/01/06/2014-01-06-samba-linux-attentions/" data-toggle="tooltip" data-placement="top" title="Linux安装Samba文件共享服务器">Next Post →</a></li></ul><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href, 
    sourceId: "",
    productKey: "fdb2db38bb5548f6bba8e02165a9f755",
    target: "cloud-tie-wrapper"
};
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);</script><div id="hot-news-wrap" class="hot-news-wrap"></div><script>var yunModuleEnv = true;</script><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var yunTieProductKey = "fdb2db38bb5548f6bba8e02165a9f755";
var yunHotNewsWrap = "hot-news-wrap";
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vZXh0ZW5kL2hvdF9uZXdzX3NjcmlwdC5odG1s", true);</script></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href="https://github.com/blademainer" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li><li><a href="/atom.xml" title="RSS"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-rss"></i></span></a></li><li><a href="mailto:blademainer@gmail.com" title="Email me"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-envelope"></i></span></a></li><li><a href="https://www.zhihu.com/people/xiong-ying-qi" title="ZhiHu"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-link"></i></span></a></li></ul><p class="copyright text-muted">© blademainer • 2017 • <a href="mailto:undefined"></a></p></div></div></div></footer><script src="/js/jquery-1.11.2.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?401b87cd7ccfbae7934d36a06c2bb321";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></body></html>