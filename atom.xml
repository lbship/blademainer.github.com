<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blademainer</title>
  
  <subtitle>IT dogs...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiongyingqi.com/"/>
  <updated>2017-11-02T08:39:14.090Z</updated>
  <id>http://xiongyingqi.com/</id>
  
  <author>
    <name>blademainer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在docker内运行java的问题</title>
    <link href="http://xiongyingqi.com/2017/04/06/2017-04-06-run-java-in-docker/"/>
    <id>http://xiongyingqi.com/2017/04/06/2017-04-06-run-java-in-docker/</id>
    <published>2017-04-06T17:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>众所周知，当我们执行没有任何调优参数（如<code>java -jar myapplication.jar</code>）的 Java 应用程序时，JVM 会自动调整几个参数，以便在执行环境中具有最佳性能。但是许多开发者发现，如果让 JVM ergonomics (即JVM人体工程学，用于自动选择和行为调整)对垃圾收集器、堆大小和运行编译器使用默认设置值，运行在Linux容器（docker,rkt,runC,lxcfs 等）中的 Java 进程会与我们的预期表现严重不符。</p></blockquote><p>本篇文章采用简单的方法来向开发人员展示在 Linux 容器中打包 Java 应用程序时应该知道什么。</p><a id="more"></a><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>我们往往把容器当虚拟机，让它定义一些虚拟 CPU 和虚拟内存。其实容器更像是一种隔离机制：它可以让一个进程中的资源（CPU，内存，文件系统，网络等）与另一个进程中的资源完全隔离。Linux 内核中的 cgroups 功能用于实现这种隔离。<br>然而，一些从执行环境收集信息的应用程序已经在 cgroups 存在之前就被执行了。“top”，“free”，“ps”，甚至 JVM 等工具都没有针对在容器内执行高度受限的 Linux 进程进行优化。</p><h2 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h2><p>实验采用的是本人编写的测试代码。代码很简单，就是不断的创建byte数组并保存到list里面。代码所在项目：<br><a href="https://github.com/blademainer/java-memory-demo" target="_blank" rel="external">blademainer/java-memory-demo</a><br>运行步骤：</p><ol><li><p>首先使用docker运行java的测试镜像，并限制其最大可用的内存为<code>64M</code></p><pre><code class="bash">docker run --name java-memory-demo --memory-swap=0 --memory-swappiness=0 -m 64m -e JAVA_OPTIONS=&quot;-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/jvmdump/&quot; -v `pwd`/jvmdump:/jvmdump -d blademainer/java-memory-demo</code></pre><blockquote><p>JAVA_OPTIONS=”-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/jvmdump/“ 的作用是：在JVM报oom时dump出堆信息。</p></blockquote></li><li><p>另起一个终端，监听镜像的事件:</p><pre><code class="bash">docker events -f image=blademainer/java-memory-demo</code></pre></li></ol><p>运行一段时间后，java容器会被杀死，运行日志如下：</p><pre><code class="bash">------------------------------------------MaxMemory: 3.46GFreeMemory: 197.48MTotalMemory: 240.0MUsable: 3.42G------------------------------------------Name: Code CachePeakUsage: init = 2555904(2.44M) used = 1242176(1.18M) committed = 2555904(2.44M) max = 251658240(240.0M)------------------------------------------Name: MetaspacePeakUsage: init = 0(0) used = 3276728(3.12M) committed = 4980736(4.75M) max = -1(-1)------------------------------------------Name: Compressed Class SpacePeakUsage: init = 0(0) used = 345832(337.73K) committed = 524288(512.0K) max = 1073741824(1.0G)------------------------------------------Name: PS Eden SpaceCollectionUsage: init = 66060288(63.0M) used = 0(0) committed = 0(0) max = 1371537408(1.28G)CollectionUsageThreshold: 0CollectionUsageThresholdCount: 0PeakUsage: init = 66060288(63.0M) used = 44585544(42.52M) committed = 66060288(63.0M) max = 1371537408(1.28G)------------------------------------------Name: PS Survivor SpaceCollectionUsage: init = 10485760(10.0M) used = 0(0) committed = 0(0) max = 10485760(10.0M)CollectionUsageThreshold: 0CollectionUsageThresholdCount: 0PeakUsage: init = 10485760(10.0M) used = 0(0) committed = 10485760(10.0M) max = 10485760(10.0M)------------------------------------------Name: PS Old GenCollectionUsage: init = 175112192(167.0M) used = 0(0) committed = 0(0) max = 2785017856(2.59G)CollectionUsageThreshold: 0CollectionUsageThresholdCount: 0PeakUsage: init = 175112192(167.0M) used = 0(0) committed = 175112192(167.0M) max = 2785017856(2.59G)------------------------------------------PS ScavengeCollectionCount: 0CollectionTime: 0ms------------------------------------------PS MarkSweepCollectionCount: 0CollectionTime: 0msAllocating memory: 10485760Killed</code></pre><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>第二步<code>docker events -f image=blademainer/java-memory-demo</code>事件监听输出如下：</p><pre><code class="bash">2017-04-29T23:01:24.753731857+08:00 container create 92f98a1773549572cf8c3435350a6d1a885196884e957b35b5e1fa572e617a3b (image=blademainer/java-memory-demo, name=java-memory-demo)2017-04-29T23:01:24.948240973+08:00 container start 92f98a1773549572cf8c3435350a6d1a885196884e957b35b5e1fa572e617a3b (image=blademainer/java-memory-demo, name=java-memory-demo)2017-04-29T23:01:25.015361538+08:00 container oom 92f98a1773549572cf8c3435350a6d1a885196884e957b35b5e1fa572e617a3b (image=blademainer/java-memory-demo, name=java-memory-demo)2017-04-29T23:01:25.092596145+08:00 container die 92f98a1773549572cf8c3435350a6d1a885196884e957b35b5e1fa572e617a3b (exitCode=137, image=blademainer/java-memory-demo, name=java-memory-demo)</code></pre><p>输出内容的第四行有个致命的报错<code>container oom</code>导致java程序直接退出。或者使用<code>docker inspect java-memory-demo</code>也能看到错误信息以及状态:</p><pre><code class="json">&quot;State&quot;: {            &quot;Status&quot;: &quot;exited&quot;,            &quot;Running&quot;: false,            &quot;Paused&quot;: false,            &quot;Restarting&quot;: false,            &quot;OOMKilled&quot;: true,            &quot;Dead&quot;: false,            &quot;Pid&quot;: 0,            &quot;ExitCode&quot;: 137,            &quot;Error&quot;: &quot;&quot;,            &quot;StartedAt&quot;: &quot;2017-04-29T15:01:24.940805854Z&quot;,            &quot;FinishedAt&quot;: &quot;2017-04-29T15:01:25.092588915Z&quot;        }</code></pre><p>docker直接杀掉了java容器，此时的退出前的java程序不会报任何错误信息也不会打印错误堆栈、调用shutdownHook等。<code>jvmdump</code>也不会有dump的文件输出：<br><img src="/images/post/run-java-in-docker-1.png" alt=""></p><h2 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h2><p>按道理JVM会自动根据当前系统的可用内存来自动分配JVM的内存大小，那么JVM分配的内存应该不大于<code>64M</code>，然而我们的java程序输出日志如下：</p><pre><code>MaxMemory: 3.46GFreeMemory: 207.48MTotalMemory: 240.0MUsable: 3.43G</code></pre><p><code>MaxMemory: 3.46G</code>代表最大可用内存为<code>3.46G</code>，明显不是我们期望的结果。JVM之所以<code>不知道</code>他所在的环境是被限制了内存大小的，是因为docker采用<a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="external">cgroup</a>技术来限制资源的，而JVM无法感知该限制，导致JVM根据宿主机器的最大内存来分配可用内存。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="使用启动参数来限制容器内JVM的内存"><a href="#使用启动参数来限制容器内JVM的内存" class="headerlink" title="使用启动参数来限制容器内JVM的内存"></a>使用启动参数来限制容器内JVM的内存</h2><pre><code class="bash">docker run --name java-memory-demo --memory-swap=0 --memory-swappiness=0 -m 256m -e JAVA_OPTIONS=&quot;-Xmx128m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/jvmdump/&quot; -v `pwd`/jvmdump:/jvmdump -d blademainer/java-memory-demo</code></pre><blockquote><p><code>JAVA_OPTIONS</code>增加了<code>-Xmx128m</code></p></blockquote><p>JVM正确的打印了异常日志日志、调用了ShutdownHook以及正确的输出了HeapDumpPath<br><img src="/images/post/run-java-in-docker-2.png" alt=""></p><h2 id="使用可以识别cgroup限制的JVM"><a href="#使用可以识别cgroup限制的JVM" class="headerlink" title="使用可以识别cgroup限制的JVM"></a>使用可以识别<code>cgroup</code>限制的<code>JVM</code></h2><ul><li><a href="http://hg.openjdk.java.net/jdk9/jdk9/hotspot/rev/5f1d1df0ea49" target="_blank" rel="external">jdk9</a></li><li><a href="https://hub.docker.com/r/fabric8/java-jboss-openjdk8-jdk/" target="_blank" rel="external">fabric8/java-jboss-openjdk8-jdk</a></li></ul><h1 id="Tomcat容器的运行"><a href="#Tomcat容器的运行" class="headerlink" title="Tomcat容器的运行"></a>Tomcat容器的运行</h1><p>运行时使用<code>JAVA_OPTS</code>环境变量：</p><pre><code class="bash">docker run --memory-swap=0 --memory-swappiness=0 -m 256m -e JAVA_OPTS=&quot;-Xmx128m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/jvmdump/&quot; -v `pwd`/jvmdump:/jvmdump tomcat</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developers.redhat.com/blog/2017/03/14/java-inside-docker/" target="_blank" rel="external">java-inside-docker</a></li><li><a href="http://docs.oracle.com/javase/1.5.0/docs/guide/vm/gc-ergonomics.html" target="_blank" rel="external">gc-ergonomics</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;众所周知，当我们执行没有任何调优参数（如&lt;code&gt;java -jar myapplication.jar&lt;/code&gt;）的 Java 应用程序时，JVM 会自动调整几个参数，以便在执行环境中具有最佳性能。但是许多开发者发现，如果让 JVM ergonomics (即JVM人体工程学，用于自动选择和行为调整)对垃圾收集器、堆大小和运行编译器使用默认设置值，运行在Linux容器（docker,rkt,runC,lxcfs 等）中的 Java 进程会与我们的预期表现严重不符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章采用简单的方法来向开发人员展示在 Linux 容器中打包 Java 应用程序时应该知道什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="docker" scheme="http://xiongyingqi.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>在docker内运行docker命令</title>
    <link href="http://xiongyingqi.com/2017/03/23/run-docker-in-docker/"/>
    <id>http://xiongyingqi.com/2017/03/23/run-docker-in-docker/</id>
    <published>2017-03-23T17:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.094Z</updated>
    
    <content type="html"><![CDATA[<p>我们的项目里面经常需要使用jenkins来编译docker，然后jenkins本身就是docker运行起来的，因此编译docker镜像就无法进行。通过调查发现：可以通过映射宿主机器的docker来达到运行的目的。<br>命令如下：</p><pre><code class="bash">docker run -it --rm \    --privileged=true \    -v /var/run/docker.sock:/var/run/docker.sock \    -v /var/run/docker:/var/run/docker \    -v /usr/bin/docker:/usr/bin/docker \    --group-add=$(stat -c %g /var/run/docker.sock) \    -v /etc/localtime:/etc/localtime:ro \    jenkins docker ps</code></pre><p>CentOS7</p><pre><code class="bash">docker run --rm \    -it \    -u root \    -v /var/run/docker.sock:/var/run/docker.sock \    -v $(which docker):/usr/bin/docker:ro \    -v /usr/lib64/libsystemd-journal.so.0:/usr/lib/x86_64-linux-gnu/libsystemd-journal.so.0 \    -v /usr/lib64/libsystemd-id128.so.0:/usr/lib/x86_64-linux-gnu/libsystemd-id128.so.0 \    -v /usr/lib64/libdevmapper.so.1.02:/usr/lib/x86_64-linux-gnu/libdevmapper.so.1.02 \    -v /usr/lib64/libgcrypt.so.11:/usr/lib/x86_64-linux-gnu/libgcrypt.so.11 \    -v /usr/lib64/libdw.so.1:/usr/lib/x86_64-linux-gnu/libdw.so.1 \    -v /usr/lib64/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7 \    jenkins docker ps</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们的项目里面经常需要使用jenkins来编译docker，然后jenkins本身就是docker运行起来的，因此编译docker镜像就无法进行。通过调查发现：可以通过映射宿主机器的docker来达到运行的目的。&lt;br&gt;命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=
      
    
    </summary>
    
    
      <category term="docker" scheme="http://xiongyingqi.com/tags/docker/"/>
    
      <category term="docker in docker" scheme="http://xiongyingqi.com/tags/docker-in-docker/"/>
    
      <category term="jenkins" scheme="http://xiongyingqi.com/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>bash快捷键</title>
    <link href="http://xiongyingqi.com/2017/03/14/bash-shortcuts/"/>
    <id>http://xiongyingqi.com/2017/03/14/bash-shortcuts/</id>
    <published>2017-03-14T21:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 终端常用快捷键</p><a id="more"></a><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><ul><li><code>ctrl+b</code>: 前移一个字符(backward)</li><li><code>ctrl+f</code>: 后移一个字符(forward)</li><li><code>alt+b</code>: 前移一个单词</li><li><code>alt+f</code>: 后移一个单词</li><li><code>ctrl+a</code>: 移到行首（a是首字母） </li><li><code>ctrl+e</code>: 移到行尾（end）</li><li><code>ctrl+x</code>: 行首到当前光标替换</li></ul><h2 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h2><ul><li><code>alt+.</code>: 粘帖最后一次命令最后的参数（通常用于<code>mkdir long-long-dir</code>后, <code>cd</code>配合着<code>alt+.</code>）</li><li><code>alt+d</code>: 删除当前光标到临近右边单词开始(delete)</li><li><code>ctrl+w</code>: 删除当前光标到临近左边单词结束(word)</li><li><code>ctrl+h</code>: 删除光标前一个字符（相当于backspace）</li><li><code>ctrl+d</code>: 删除光标后一个字符（相当于delete）</li><li><code>ctrl+u</code>: 删除光标左边所有</li><li><code>ctrl+k</code>: 删除光标右边所有</li><li><code>ctrl+l</code>: 清屏</li><li><code>ctrl+shift+c</code>: 复制（相当于鼠标左键拖拽）</li><li><code>ctrl+shift+v</code>: 粘贴（相当于鼠标中键）</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><code>ctrl+n</code>: 下一条命令</li><li><code>ctrl+p</code>: 上一条命令</li><li><code>alt+n</code>: 下一条命令（例如输入<code>ls</code>, 然后按’alt+n’, 就会找到历史记录下的<code>ls</code>命令）</li><li><code>alt+p</code>: 上一条命令（跟<code>alt+n</code>相似）</li><li><code>shift+PageUp</code>: 向上翻页</li><li><code>shift+PageDown</code>: 向下翻页</li><li><code>ctrl+r</code>: 进入历史查找命令记录， 输入关键字。 多次按返回下一个匹配项</li></ul><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><ul><li><code>d</code>: 列出以前的打开的命令</li><li><code>j</code>: jump到以前某个目录，模糊匹配</li></ul><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="移动光标-1"><a href="#移动光标-1" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li><code>b</code>: 向前移动一个单词</li><li><code>w</code>: 向后移动一个单词</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><code>dw</code>: 从当前光标开始删除到下一个单词头</li><li><code>de</code>: 从当前光标开始删除到单词尾</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 终端常用快捷键&lt;/p&gt;
    
    </summary>
    
    
      <category term="bash" scheme="http://xiongyingqi.com/tags/bash/"/>
    
      <category term="shortcuts" scheme="http://xiongyingqi.com/tags/shortcuts/"/>
    
      <category term="快捷键" scheme="http://xiongyingqi.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>openjdk阅读笔记</title>
    <link href="http://xiongyingqi.com/2017/02/17/2017-02-17-openjdk-read-note/"/>
    <id>http://xiongyingqi.com/2017/02/17/2017-02-17-openjdk-read-note/</id>
    <published>2017-02-17T11:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="openjdk目录结构"><a href="#openjdk目录结构" class="headerlink" title="openjdk目录结构"></a>openjdk目录结构</h1><pre><code>├─agent                            Serviceability Agent的客户端实现├─make                             用来build出HotSpot的各种配置文件├─src                              HotSpot VM的源代码│  ├─cpu                            CPU相关代码（汇编器、模板解释器、ad文件、部分runtime函数在这里实现）│  ├─os                             操作系相关代码│  ├─os_cpu                         操作系统+CPU的组合相关的代码│  └─share                          平台无关的共通代码│      ├─tools                        工具│      │  ├─hsdis                      反汇编插件│      │  ├─IdealGraphVisualizer       将server编译器的中间代码可视化的工具│      │  ├─launcher                   启动程序“java”│      │  ├─LogCompilation             将-XX:+LogCompilation输出的日志（hotspot.log）整理成更容易阅读的格式的工具│      │  └─ProjectCreator             生成Visual Studio的project文件的工具│      └─vm                           HotSpot VM的核心代码│          ├─adlc                       平台描述文件（上面的cpu或os_cpu里的*.ad文件）的编译器│          ├─asm                        汇编器接口│          ├─c1                         client编译器（又称“C1”）│          ├─ci                         动态编译器的公共服务/从动态编译器到VM的接口│          ├─classfile                  类文件的处理（包括类加载和系统符号表等）│          ├─code                       动态生成的代码的管理│          ├─compiler                   从VM调用动态编译器的接口│          ├─gc_implementation          GC的实现│          │  ├─concurrentMarkSweep      Concurrent Mark Sweep GC的实现│          │  ├─g1                       Garbage-First GC的实现（不使用老的分代式GC框架）│          │  ├─parallelScavenge         ParallelScavenge GC的实现（server VM默认，不使用老的分代式GC框架）│          │  ├─parNew                   ParNew GC的实现│          │  └─shared                   GC的共通实现│          ├─gc_interface               GC的接口│          ├─interpreter                解释器，包括“模板解释器”（官方版在用）和“C++解释器”（官方版不在用）│          ├─libadt                     一些抽象数据结构│          ├─memory                     内存管理相关（老的分代式GC框架也在这里）│          ├─oops                       HotSpot VM的对象系统的实现│          ├─opto                       server编译器（又称“C2”或“Opto”）│          ├─prims                      HotSpot VM的对外接口，包括部分标准库的native部分和JVMTI实现│          ├─runtime                    运行时支持库（包括线程管理、编译器调度、锁、反射等）│          ├─services                   主要是用来支持JMX之类的管理功能的接口│          ├─shark                      基于LLVM的JIT编译器（官方版里没有使用）│          └─utilities                  一些基本的工具类└─test                             单元测试</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;openjdk目录结构&quot;&gt;&lt;a href=&quot;#openjdk目录结构&quot; class=&quot;headerlink&quot; title=&quot;openjdk目录结构&quot;&gt;&lt;/a&gt;openjdk目录结构&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;├─agent                   
      
    
    </summary>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="openjdk" scheme="http://xiongyingqi.com/tags/openjdk/"/>
    
      <category term="hotspot" scheme="http://xiongyingqi.com/tags/hotspot/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴Java开发手册</title>
    <link href="http://xiongyingqi.com/2017/02/14/ali-java-specification/"/>
    <id>http://xiongyingqi.com/2017/02/14/ali-java-specification/</id>
    <published>2017-02-14T11:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><a href="#一-编程规约">一 编程规约</a><ul><li><a href="#一-命名规约">(一) 命名规约</a></li><li><a href="#二-常量定义">(二) 常量定义</a></li><li><a href="#三-格式规约">(三) 格式规约</a></li><li><a href="#四-OOP规约">(四) OOP规约</a></li><li><a href="#五-集合处理">(五) 集合处理</a></li><li><a href="#六-并发处理">(六) 并发处理</a></li><li><a href="#七-控制语句">(七) 控制语句</a></li><li><a href="#八-注释规约">(八) 注释规约</a></li><li><a href="#九-其它">(九) 其它</a></li></ul></li><li><a href="#二-异常日志">二 异常日志</a><ul><li><a href="#一-异常处理">(一) 异常处理</a></li><li><a href="#二-日志规约">(二) 日志规约</a></li></ul></li><li><a href="#三-MySQL规约">三 MySQL规约</a><ul><li><a href="#一-建表规约">(一) 建表规约</a></li><li><a href="#二-索引规约">(二) 索引规约</a></li><li><a href="#三-SQL规约">(三) SQL规约</a></li><li><a href="#四-ORM规约">(四) ORM规约</a></li></ul></li><li><a href="#四-工程规约">四 工程规约</a><ul><li><a href="#一-应用分层">(一) 应用分层</a></li><li><a href="#二-二方库规约">(二) 二方库规约</a></li><li><a href="#三-服务器规约">(三) 服务器规约</a></li></ul></li><li><a href="#五-安全规约">五 安全规约</a></li></ul><hr><a id="more"></a><h1 id="一-编程规约"><a href="#一-编程规约" class="headerlink" title="一 编程规约"></a>一 编程规约</h1><h2 id="一-命名规约"><a href="#一-命名规约" class="headerlink" title="(一)命名规约"></a>(一)命名规约</h2><ol><li>【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。   <blockquote><p>反例： <em>name / __name / $Object / name</em> / name$ / Object$   </p></blockquote></li><li><p>【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。   </p><blockquote><p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。<br>反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3<br>正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。</p></blockquote></li><li><p>【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等。   </p><blockquote><p>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion  </p></blockquote></li><li><p>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。   </p><blockquote><p>正例： localValue / getHttpMessage() / inputUserId </p></blockquote></li><li><p>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。   </p><blockquote><p>正例： MAX_STOCK_COUNT<br>反例： MAX_COUNT </p></blockquote></li><li><p>【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。   </p></li><li><p>【强制】中括号是数组类型的一部分，数组定义如下：String[] args;   </p><blockquote><p>反例：使用 String args[]的方式来定义。   </p></blockquote></li><li><p>【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。   </p><blockquote><p>反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。 </p></blockquote></li><li><p>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。   </p><blockquote><p>正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考spring 的框架结构） </p></blockquote></li><li><p>【强制】杜绝完全不规范的缩写，避免望文不知义。   </p><blockquote><p>反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 </p></blockquote></li><li><p>【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。   </p><blockquote><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br>正例：public class OrderFactory;<br> public class LoginProxy;<br> public class ResourceObserver; </p></blockquote></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。   </p><blockquote><p>正例：接口方法签名：void f();<br>接口基础常量表示：String COMPANY = “alibaba”;<br>反例：接口方法定义：public abstract void f();<br>说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 </p></blockquote></li><li><p>接口和实现类的命名有两套规则：<br>1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。   </p><blockquote><p>正例：CacheServiceImpl 实现 CacheService 接口。 </p></blockquote><p>2） 【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。   </p><blockquote><p>正例：AbstractTranslator 实现 Translatable。 </p></blockquote></li><li><p>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。   </p><blockquote><p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。 </p></blockquote></li><li><p>【参考】各层命名规约：    </p><ul><li>A) Service/DAO 层方法命名规约<br>1） 获取单个对象的方法用 get 做前缀。<br>2） 获取多个对象的方法用 list 做前缀。<br>3） 获取统计值的方法用 count 做前缀。<br>4） 插入的方法用 save（推荐）或 insert 做前缀。<br>5） 删除的方法用 remove（推荐）或 delete 做前缀。<br>6） 修改的方法用 update 做前缀。   </li><li>B) 领域模型命名规约<br>1） 数据对象：xxxDO，xxx 即为数据表名。<br>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>3） 展示对象：xxxVO，xxx 一般为网页名称。<br>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。   </li></ul></li></ol><h2 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="(二)常量定义"></a>(二)常量定义</h2><ol><li><p>【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。   </p><blockquote><p> 反例： String key=”Id#taobao_”+tradeId；   </p><pre><code> cache.put(key, value);   </code></pre></blockquote></li><li><p>【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。   </p><blockquote><p>说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?   </p></blockquote></li><li><p>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。   </p><blockquote><p>说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p></blockquote></li></ol><ol><li><p>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。   </p><ul><li>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。   </li><li><p>2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。   </p><blockquote><pre><code>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：   </code></pre><p>   类 A 中：public static final String YES = “yes”;<br>   类 B 中：public static final String YES = “y”;<br>   A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致产生线上问题。   </p></blockquote></li><li><p>3） 子工程内部共享常量：即在当前子工程的 constant 目录下。   </p></li><li>4） 包内共享常量：即在当前包下单独的 constant 目录下。   </li><li>5） 类内共享常量：直接在类内部 private static final 定义。   </li></ul></li><li>【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类，下面正例中的数字就是延伸信息，表示星期几。   <blockquote><p>正例：public Enum{ MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}   </p></blockquote></li></ol><h2 id="三-格式规约"><a href="#三-格式规约" class="headerlink" title="(三)格式规约"></a>(三)格式规约</h2><ol><li>【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：   <ul><li>1） 左大括号前不换行。   </li><li>2） 左大括号后换行。   </li><li>3） 右大括号前换行。   </li><li>4） 右大括号后还有 else 等代码则不换行；表示终止右大括号后必须换行。   </li></ul></li><li>【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空格。详见第 5 条下方正例提示。   </li><li>【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。   </li><li><p>【强制】任何运算符左右必须加一个空格。   </p><blockquote><p>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。   </p></blockquote></li><li><p>【强制】缩进采用 4 个空格，禁止使用 tab 字符。   </p><blockquote><p>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，<br>请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。<br>正例： （涉及 1-5 点） </p></blockquote></li></ol><pre><code class="java">public static void main(String[] args) {            // 缩进 4 个空格            String say = &quot;hello&quot;;            // 运算符的左右必须有一个空格            int flag = 0;           // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格            if (flag == 0) {                    System.out.println(say);            }            // 左大括号前加空格且不换行；左大括号后换行            if (flag == 1) {                    System.out.println(&quot;world&quot;);            // 右大括号前换行，右大括号后有 else，不用换行            } else {                      System.out.println(&quot;ok&quot;);            // 在右大括号后直接结束，则必须换行            }    }</code></pre><ol><li><p>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：  </p><ul><li>1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。  </li><li>2）运算符与下文一起换行。  </li><li>3）方法调用的点符号与下文一起换行。  </li><li>4）在多个参数超长，逗号后进行换行。  </li><li>5）在括号前不要换行，见反例。  <blockquote><p>正例： </p><pre><code class="java">StringBuffer sb = new StringBuffer();    //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行    sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...      .append(&quot;huang&quot;)...    .append(&quot;huang&quot;)...    .append(&quot;huang&quot;);</code></pre><p>反例：</p><pre><code class="java">StringBuffer sb = new StringBuffer();    //超过 120 个字符的情况下，不要在括号前换行    sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append(&quot;huang&quot;);     //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行   method(args1, args2, args3, ...      , argsX);</code></pre></blockquote></li></ul></li><li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。   </p><blockquote><p>正例：下例中实参的”a”,后边必须要有一个空格。<br>method(“a”, “b”, “c”);  </p></blockquote></li><li><p>【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。   </p></li><li><p>【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。   </p><blockquote><p>正例：   </p><pre><code class="java">int a = 3;    long b = 4L;    float c = 5F;    StringBuffer sb = new StringBuffer();</code></pre><p>说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。 </p></blockquote></li><li><p>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。   </p><blockquote><p>说明：没有必要插入多行空格进行隔开。</p></blockquote></li></ol><h2 id="四-OOP-规约"><a href="#四-OOP-规约" class="headerlink" title="(四)OOP 规约"></a>(四)OOP 规约</h2><ol><li>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。   </li><li><p>【强制】所有的覆写方法，必须加@Override 注解。   </p><blockquote><p>反例：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 </p></blockquote></li><li><p>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。   </p><blockquote><p>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br>正例：public User getUsers(String type, Integer… ids)  </p></blockquote></li><li><p>【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。   </p></li><li><p>【强制】不能使用过时的类或方法。   </p><blockquote><p>说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 </p></blockquote></li><li><p>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。   </p><blockquote><p>正例： “test”.equals(object);<br>反例： object.equals(“test”);<br>说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）  </p></blockquote></li><li><p>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。   </p><blockquote><p>说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 </p></blockquote></li><li><p>【强制】关于基本数据类型与包装数据类型的使用标准如下：   </p><ul><li>1） 所有的 POJO 类属性必须使用包装数据类型。   </li><li>2） RPC 方法的返回值和参数必须使用包装数据类型。   </li><li>3） 所有的局部变量【推荐】使用基本数据类型。   <blockquote><p>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由使用者来保证。<br>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br>反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 </p></blockquote></li></ul></li><li><p>【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。   </p><blockquote><p>反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 </p></blockquote></li><li><p>【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。   </p><blockquote><p>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。 </p></blockquote></li><li><p>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。   </p></li><li><p>【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。   </p><blockquote><p>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。 </p></blockquote></li><li><p>【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。   </p><blockquote><p>说明： </p><pre><code class="java">String str = &quot;a,b,c,,&quot;;    String[] ary = str.split(&quot;,&quot;);    //预期大于 3，结果是 3   System.out.println(ary.length);</code></pre></blockquote></li><li><p>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。   </p></li><li><p>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。   </p><blockquote><p>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。   </p></blockquote></li><li><p>【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。   </p><blockquote><p>反例：   </p><pre><code class="java">public Integer getData(){        if(true)  {        return data + 100;    } else  {       return data - 100;   }    }</code></pre></blockquote></li><li><p>【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。   </p><blockquote><p>反例： </p><pre><code class="java">String str = &quot;start&quot;;        for(int i=0; i&lt;100; i++){            str = str + &quot;hello&quot;;        }</code></pre><p>说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 </p></blockquote></li><li><p>【推荐】final 可提高程序响应效率，声明成 final 的情况：</p><ul><li>1） 不需要重新赋值的变量，包括类属性、局部变量。</li><li>2） 对象参数前加 final，表示不允许修改引用的指向。</li><li>3） 类方法确定不允许被重写。</li></ul></li></ol><ol><li><p>【推荐】慎用 Object 的 clone 方法来拷贝对象。   </p><blockquote><p>说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。 </p></blockquote></li><li><p>【推荐】类成员与方法访问控制从严：</p><ul><li>1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。 </li><li>2） 工具类不允许有 public 或 default 构造方法。</li><li>3） 类非 static 成员变量并且与子类共享，必须是 protected。</li><li>4） 类非 static 成员变量并且仅在本类使用，必须是 private。</li><li>5） 类 static 成员变量如果仅在本类使用，必须是 private。</li><li>6） 若是 static 成员变量，必须考虑是否为 final。</li><li>7） 类成员方法只供类内部调用，必须是 private。</li><li>8） 类成员方法只对继承类公开，那么限制为 protected。<blockquote><p>说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。   </p></blockquote></li></ul></li></ol><h2 id="五-集合处理"><a href="#五-集合处理" class="headerlink" title="(五)集合处理"></a>(五)集合处理</h2><ol><li><p>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：   </p><ul><li>1） 只要重写 equals，就必须重写 hashCode。   </li><li>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。   </li><li>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。   <blockquote><p>正例：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。 </p></blockquote></li></ul></li><li><p>【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;   </p><blockquote><p>说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。 </p></blockquote></li><li><p>【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常。   </p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。   </p><blockquote><p>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。<br>正例：   </p><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);        list.add(&quot;guan&quot;);        list.add(&quot;bao&quot;);         String[] array = new String[list.size()];        array = list.toArray(array);</code></pre><p>说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 </p></blockquote></li><li><p>【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。   </p><blockquote><p>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br> String[] str = new String[] { “a”, “b” };<br> List list = Arrays.asList(str);<br>第一种情况：list.add(“c”); 运行时异常。<br>第二种情况：str[0]= “gujin”; 那么 list.get(0)也会随之修改。   </p></blockquote></li><li><p>【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。   </p><blockquote><p>说明：苹果装箱后返回一个&lt;? extends Fruits&gt;对象，此对象就不能往里加任何水果，包括苹果。 </p></blockquote></li><li><p>【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。   </p><blockquote><p>反例： </p><pre><code class="java">List&lt;String&gt; a = new ArrayList&lt;String&gt;();        a.add(&quot;1&quot;);        a.add(&quot;2&quot;);        for (String temp : a) {             if(&quot;1&quot;.equals(temp)){                     a.remove(temp);             }        }</code></pre><p>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？<br>正例： </p><pre><code class="java">Iterator&lt;String&gt; it = a.iterator();    while(it.hasNext()){                 String temp =  it.next();                          if(删除元素的条件){                                     it.remove();                    }        }</code></pre></blockquote></li><li><p>【强制】 在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。<br>说明：   </p><ul><li>1） 自反性：x，y 的比较结果和 y，x 的比较结果相反。   </li><li>2） 传递性：x&gt;y,y&gt;z,则 x&gt;z。   </li><li>3） 对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。   <blockquote><p>反例：下例中没有处理相等的情况，实际使用中可能会出现异常： </p><pre><code class="java">new Comparator&lt;Student&gt;() {             @Override            public int compare(Student o1, Student o2) {                   return o1.getId() &gt; o2.getId() ? 1 : -1;            }        }</code></pre></blockquote></li></ul></li><li><p>【推荐】集合初始化时，尽量指定集合初始值大小。   </p><blockquote><p>说明：ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。 </p></blockquote></li><li><p>【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。   </p><blockquote><p>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。<br>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。 </p></blockquote></li><li><p>【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：</p></li></ol><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>不允许为 null</td><td>不允许为 null</td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>不允许为 null</td><td>不允许为 null</td><td>AbstractMap</td><td>分段锁技术</td></tr><tr><td>TreeMap</td><td>不允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>HashMap</td><td>允许为 null</td><td>允许为 null</td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table><blockquote><p>反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，注意存储null 值时会抛出 NPE 异常。</p></blockquote><ol><li><p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。   </p><blockquote><p>说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是order/sort。 </p></blockquote></li><li><p>【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。</p></li></ol><h2 id="六-并发处理"><a href="#六-并发处理" class="headerlink" title="(六)并发处理"></a>(六)并发处理</h2><ol><li><p>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。   </p><blockquote><p>说明：资源驱动类、工具类、单例工厂类都需要注意。 </p></blockquote></li><li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。   </p><blockquote><p>正例：  </p><pre><code class="java">public class TimerTaskThread extends Thread {         public TimerTaskThread(){                 super.setName(&quot;TimerTaskThread&quot;);       ...     }}</code></pre></blockquote></li><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。   </p><blockquote><p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 </p></blockquote></li><li><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。   </p><blockquote><p>说明：Executors 返回的线程池对象的弊端如下：   </p><ul><li>1）FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。   </li><li>2）CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ul></blockquote></li><li><p>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。   </p><blockquote><p>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：   </p><pre><code class="java">private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {   @Override           protected DateFormat initialValue() {     return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); }};</code></pre><p>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter代替 Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。   </p></blockquote></li><li><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。   </p></li><li><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。   </p><blockquote><p>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。 </p></blockquote></li><li><p>【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。   </p><blockquote><p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。   </p></blockquote></li><li><p>【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。   </p></li><li><p>【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。   </p><blockquote><p>说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。   </p></blockquote></li><li><p>【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。   </p><blockquote><p>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()实例。<br>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每个线程一个实例。   </p></blockquote></li><li><p>【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。   </p><blockquote><p>反例： </p><pre><code class="java">class Foo {     private Helper helper = null;    public Helper getHelper() {        if (helper == null)           synchronized(this) {                    if (helper == null)                           helper = new Helper();              }            return helper;    }    // other functions and members...    }</code></pre></blockquote></li><li><p>【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：  </p><pre><code class="java">AtomicInteger count = new AtomicInteger(); count.addAndGet(1);</code></pre><p>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。   </p></li><li>【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。   </li><li>【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。   </li></ol><h2 id="七-控制语句"><a href="#七-控制语句" class="headerlink" title="(七)控制语句"></a>(七)控制语句</h2><ol><li>【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。   </li><li>【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) statements;   </li><li><p>【推荐】推荐尽量少用 else， if-else 的方式可以改写成： </p><pre><code class="java">if(condition){             ...            return obj;      }  // 接着写 else 的业务逻辑代码;</code></pre><blockquote><p>说明：如果非得使用 if()…else if()…else…方式表达逻辑，【强制】请勿超过 3 层，超过请使用状态设计模式。<br>正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。 </p></blockquote></li><li><p>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。   </p><blockquote><p>说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？<br>正例： </p><pre><code class="java">//伪代码如下   boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...);   if (existed) {    ...   }     反例：if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) {    ...}</code></pre></blockquote></li><li><p>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</p></li><li>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。   </li><li>【参考】方法中需要进行参数校验的场景：   <ul><li>1） 调用频次低的方法。   </li><li>2） 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。   </li><li>3） 需要极高稳定性和可用性的方法。   </li><li>4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。   </li><li>5） 敏感权限入口。   </li></ul></li><li>【参考】方法中不需要参数校验的场景：   <ul><li>1） 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参数检查。   </li><li>2） 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。   </li><li>3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。   </li></ul></li></ol><h2 id="八-注释规约"><a href="#八-注释规约" class="headerlink" title="(八)注释规约"></a>(八)注释规约</h2><ol><li><p>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/<em>*内容</em>/格式，不得使用//xxx 方式。   </p><blockquote><p>说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。   </p></blockquote></li><li><p>【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。   </p><blockquote><p>说明：对子类的实现要求，或者调用注意事项，请一并说明。   </p></blockquote></li><li><p>【强制】所有的类都必须添加创建者信息。   </p></li><li>【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/<em> </em>/注释，注意与代码对齐。   </li><li>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。   </li><li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。   </p><blockquote><p>反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。   </p></blockquote></li><li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。   </p><blockquote><p>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。   </p></blockquote></li><li><p>【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。   </p><blockquote><p>说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。   </p></blockquote></li><li><p>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。   </p></li><li><p>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。   </p><blockquote><p>反例： </p><pre><code class="java">// put elephant into fridge    put(elephant, fridge);</code></pre><p>方法名put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。 </p></blockquote></li><li><p>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。   </p><ul><li>1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。   </li><li>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）<br>在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。   </li></ul></li></ol><h2 id="九-其它"><a href="#九-其它" class="headerlink" title="(九)其它"></a>(九)其它</h2><ol><li><p>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。   </p><blockquote><p>说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);   </p></blockquote></li><li><p>【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。   </p><blockquote><p>说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。   </p></blockquote></li><li><p>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。   </p><blockquote><p>说明：如果 var=null 或者不存在，那么${var}会直接显示在页面上。   </p></blockquote></li><li><p>【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。   </p></li><li><p>【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();   </p><blockquote><p>说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime()。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。   </p></blockquote></li><li><p>【推荐】尽量不要在 velocity 模板中加入变量声明、逻辑运算符，更不要在模板中加入任何复杂的逻辑。   </p></li><li>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。   </li><li>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。   </li></ol><h1 id="二-异常日志"><a href="#二-异常日志" class="headerlink" title="二 异常日志"></a>二 异常日志</h1><h2 id="一-异常处理"><a href="#一-异常处理" class="headerlink" title="(一)异常处理"></a>(一)异常处理</h2><ol><li><p>【强制】不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类，如：<br>IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保证程序健壮性。   </p><blockquote><p>正例：if(obj != null) {…}<br>反例：try { obj.method() } catch(NullPointerException e){…}   </p></blockquote></li><li><p>【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。   </p></li><li>【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。   </li><li>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。   </li><li>【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。   </li><li><p>【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。   </p><blockquote><p>说明：如果 JDK7，可以使用 try-with-resources 方式。 7. 【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。   </p></blockquote></li><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。   </p><blockquote><p>说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。   </p></blockquote></li><li><p>【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。   </p><blockquote><p>说明：本规约明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回 null 的情况。   </p></blockquote></li><li><p>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：   </p><ul><li>1） 返回类型为包装数据类型，有可能是 null，返回 int 值时注意判空。<br>反例：public int f(){ return Integer 对象}; 如果为 null，自动解箱抛 NPE。   </li><li>2） 数据库的查询结果可能为 null。   </li><li>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。   </li><li>4） 远程调用返回对象，一律要求进行 NPE 判断。   </li><li>5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。   </li><li>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。   </li></ul></li><li><p>【推荐】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess、“错误码”、“错误简短信息”。<br>说明：关于 RPC 方法返回方式使用 Result 方式的理由：   </p><ul><li>1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。   </li><li>2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。   </li></ul></li><li><p>【推荐】定义时区分 unchecked / checked 异常，避免直接使用 RuntimeException 抛出，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。   </p></li><li>【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。   <blockquote><p>说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。<br>正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto){…}    </p></blockquote></li></ol><h2 id="二-日志规约"><a href="#二-日志规约" class="headerlink" title="(二)日志规约"></a>(二)日志规约</h2><ol><li>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。   <pre><code class="java">import org.slf4j.Logger;    import org.slf4j.LoggerFactory;   private static final Logger logger = LoggerFactory.getLogger(Abc.class);</code></pre></li><li>【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。   </li><li><p>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：  appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。   </p><blockquote><p>正例：mppserver 应用中单独监控时区转换异常，如：<br>mppserver_monitor_timeZoneConvert.log<br>说明：推荐对日志进行分类，错误日志和业务日志尽量分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。   </p></blockquote></li><li><p>【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。   </p><blockquote><p>说明：logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol);<br>如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。<br>正例：（条件） </p><pre><code class="java">if (logger.isDebugEnabled()) {      logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol);     }</code></pre><p>正例：（占位符） </p><pre><code class="java">logger.debug(&quot;Processing trade with id: {} symbol : {} &quot;, id, symbol);</code></pre></blockquote></li><li><p>【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。   </p><blockquote><p>正例：<logger name="com.taobao.dubbo.config" additivity="false">    </logger></p></blockquote></li><li><p>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么往上抛。   </p><blockquote><p>正例：logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e);   </p></blockquote></li><li><p>【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。   </p></li><li><p>【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。   </p><blockquote><p>说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？   </p></blockquote></li></ol><h1 id="三-MySQL规约"><a href="#三-MySQL规约" class="headerlink" title="三 MySQL规约"></a>三 MySQL规约</h1><h2 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一)建表规约"></a>(一)建表规约</h2><ol><li><p>【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否），此规则同样适用于 odps 建表。   </p><blockquote><p>说明：任何字段如果为非负数，必须是 unsigned。   </p></blockquote></li><li><p>【强制】表名、字段名必须使用小写字母或数字；禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。   </p><blockquote><p>正例：getter_admin，task_config，level3_name<br>反例：GetterAdmin，taskConfig，level_3_name   </p></blockquote></li><li><p>【强制】表名不使用复数名词。   </p><blockquote><p>说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。   </p></blockquote></li><li><p>【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。   </p></li><li><p>【强制】唯一索引名为 uk<em>字段名；普通索引名则为 idx</em>字段名。   </p><blockquote><p>说明：uk<em> 即 unique key；idx</em> 即 index 的简称。   </p></blockquote></li><li><p>【强制】小数类型为 decimal，禁止使用 float 和 double。   </p><blockquote><p>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。   </p></blockquote></li><li><p>【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。   </p></li><li>【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。   </li><li><p>【强制】表必备三字段：id, gmt_create, gmt_modified。   </p><blockquote><p>说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。   </p></blockquote></li><li><p>【推荐】表的命名最好是加上“业务名称_表的作用”。   </p><blockquote><p>正例：tiger_task / tiger_reader / mpp_config   </p></blockquote></li><li><p>【推荐】库名与应用名称尽量一致。   </p></li><li>【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。   </li><li><p>【推荐】字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：   </p><ul><li>1）不是频繁修改的字段。   </li><li>2）不是 varchar 超长字段，更不能是 text 字段。   <blockquote><p>正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。   </p></blockquote></li></ul></li><li><p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。   </p><blockquote><p>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。   </p></blockquote></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。   </p><blockquote><p>正例：人的年龄用 unsigned tinyint（表示范围 0-255，人的寿命不会超过 255 岁）；海龟就必须是 smallint，但如果是太阳的年龄，就必须是 int；如果是所有恒星的年龄都加起来，那么就必须使用 bigint。   </p></blockquote></li></ol><h2 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二)索引规约"></a>(二)索引规约</h2><ol><li><p>【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。   </p><blockquote><p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验和控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。   </p></blockquote></li><li><p>【强制】 超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。   </p><blockquote><p>说明：即使双表 join 也要注意表索引、SQL 性能。   </p></blockquote></li><li><p>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。   </p><blockquote><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。   </p></blockquote></li><li><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。   </p><blockquote><p>说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。   </p></blockquote></li><li><p>【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。   </p><blockquote><p>正例：where a=? and b=? order by c; 索引：a_b_c<br>反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引a_b 无法排序。   </p></blockquote></li><li><p>【推荐】利用覆盖索引来进行查询操作，来避免回表操作。   </p><blockquote><p>说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br>正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。   </p></blockquote></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。   </p><blockquote><p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。<br>正例：先快速定位需要获取的 id 段，然后再关联： </p><pre><code class="sql">SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></pre></blockquote></li><li><p>【推荐】 SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts最好。<br>说明：   </p><ul><li>1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。   </li><li>2）ref 指的是使用普通的索引（normal index）。   </li><li>3）range 对索引进行范围检索。   <blockquote><p>反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。   </p></blockquote></li></ul></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。   </p><blockquote><p>正例：如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。<br>说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a&gt;? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。   </p></blockquote></li><li><p>【参考】创建索引时避免有如下极端误解：   </p><ul><li>1）误认为一个查询就需要建一个索引。   </li><li>2）误认为索引会消耗空间、严重拖慢更新和新增速度。   </li><li>3）误认为唯一索引一律需要在应用层通过“先查后插”方式解决。   </li></ul></li></ol><h2 id="三-SQL-规约"><a href="#三-SQL-规约" class="headerlink" title="(三)SQL 规约"></a>(三)SQL 规约</h2><ol><li><p>【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)就是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。   </p><blockquote><p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。   </p></blockquote></li><li><p>【强制】count(distinct col) 计算该列除 NULL 之外的不重复数量。注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。   </p></li><li><p>【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。   </p><blockquote><p>正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;   </p></blockquote></li><li><p>【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。   </p><blockquote><p>说明：   </p><ul><li>1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。   </li><li>2） NULL=NULL 的返回结果是 NULL，而不是 true。   </li><li>3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。   </li></ul></blockquote></li><li><p>【强制】 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。   </p></li><li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。   </p><blockquote><p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。 如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。   </p></blockquote></li><li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。   </p></li><li>【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。   </li><li>【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。   </li><li><p>【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，那么字符计数方法注意：   </p><blockquote><p>说明：<br>SELECT LENGTH(“轻松工作”)； 返回为 12<br>SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4<br>如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。 </p></blockquote></li><li><p>【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。   </p><blockquote><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。   </p></blockquote></li></ol><h2 id="四-ORM-规约"><a href="#四-ORM-规约" class="headerlink" title="(四)ORM 规约"></a>(四)ORM 规约</h2><ol><li><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。   </p><blockquote><p>说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。   </p></blockquote></li><li><p>【强制】POJO 类的 boolean 属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。   </p><blockquote><p>说明：参见定义 POJO 类以及数据库字段定义规定，在 sql.xml 增加映射，是必须的。   </p></blockquote></li><li><p>【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。   </p><blockquote><p>说明：配置映射关系，使字段与 DO 类解耦，方便维护。   </p></blockquote></li><li><p>【强制】xml 配置中参数注意使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。   </p></li><li><p>【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。   </p><blockquote><p>说明： 其实现方式是在数据库取到 statementName对应的SQL语句的所有记录，再通过 subList取 start,size 的子集合，线上因为这个原因曾经出现过 OOM。<br>? 正例：在 sqlmap.xml 中引入 #start#, #size#   </p><pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();      map.put(&quot;start&quot;, start);      map.put(&quot;size&quot;, size);</code></pre></blockquote></li><li><p>【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。   </p></li><li>【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。   </li><li>【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，尽量不要更新无改动的字段，一是易出错；二是效率低；三是 binlog 增加存储。   </li><li>【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。   </li><li>【参考】<isequal>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isnotempty>表示不为空且不为 null 时执行；<isnotnull>表示不为 null 值时执行。     </isnotnull></isnotempty></isequal></li></ol><h1 id="四-工程规约"><a href="#四-工程规约" class="headerlink" title="四 工程规约"></a>四 工程规约</h1><h2 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一)应用分层"></a>(一)应用分层</h2><ol><li><p>【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web 层，也可以直接依赖于 Service 层，依此类推：   </p><ul><li>开放接口层：可直接封装 Service 接口暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。   </li><li>终端显示层：各个端的模板渲染并执行显示层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示层等。   </li><li>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。   </li><li>Service 层：相对具体的业务逻辑服务层。   </li><li>Manager 层：通用业务处理层，它有如下特征：   <ul><li>1） 对第三方平台封装的层，预处理返回结果及转化异常信息；   </li><li>2） 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；   </li><li>3） 与 DAO 层交互，对 DAO 的业务通用能力的封装。   </li></ul></li><li>DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。   </li><li>外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。 </li></ul></li><li><p>【参考】 （分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度异常进行catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录日志信息到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常， 因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。   </p></li><li>【参考】分层领域模型规约：   <ul><li>DO（Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。   </li><li>DTO（Data Transfer Object）：数据传输对象，Service 和 Manager 向外传输的对象。   </li><li>BO（Business Object）：业务对象。可以由 Service 层输出的封装业务逻辑的对象。   </li><li>QUERY：数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。   </li><li>VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。   </li></ul></li></ol><h2 id="二-二方库规约"><a href="#二-二方库规约" class="headerlink" title="(二)二方库规约"></a>(二)二方库规约</h2><ol><li><p>【强制】定义 GAV 遵从以下规则：   </p><ul><li><p>1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。   </p><blockquote><p>说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。<br>正例：com.taobao.jstorm 或 com.alibaba.dubbo.register  </p></blockquote></li><li><p>2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。   </p><blockquote><p>正例：dubbo-client / fastjson-api / jstorm-tool </p></blockquote></li><li><p>3） Version：详细规定参考下方。 </p></li></ul></li><li><p>【强制】二方库版本号命名方式：主版本号.次版本号.修订号   </p><ul><li>1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。   </li><li>2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。   </li><li>3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。   <blockquote><p>说明：起始版本号必须为：1.0.0，而不是 0.0.1 </p></blockquote></li></ul></li><li><p>【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）；正式发布的类库必须使用 RELEASE版本号升级+1 的方式，且版本号不允许覆盖升级，必须去中央仓库进行查证。   </p><blockquote><p>说明：不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。   </p></blockquote></li><li><p>【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一致，那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。   </excludes></p></li><li>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。   </li><li><p>【强制】依赖于一个二方库群时，必须定义一个统一版本变量，避免版本号不一致。   </p><blockquote><p>说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。   </p></blockquote></li><li><p>【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的Version。   </p><blockquote><p>说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的 lib 目录中。曾经出现过线下调试是正确的，发布到线上出故障的先例。   </p></blockquote></li><li><p>【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencymanagement>语句块中。   </dependencymanagement></dependencies></p><blockquote><p>说明：<dependencymanagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的<dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。   </dependencies></dependencies></dependencymanagement></p></blockquote></li><li><p>【推荐】二方库尽量不要有配置项，最低限度不要再增加配置项。   </p></li><li>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：   <ul><li>1）精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log 具体实现，只依赖日志框架。   </li><li>2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。   </li></ul></li></ol><h2 id="三-服务器规约"><a href="#三-服务器规约" class="headerlink" title="(三)服务器规约"></a>(三)服务器规约</h2><ol><li><p>【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。   </p><blockquote><p>说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。<br>正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：<br>  net.ipv4.tcp_fin_timeout = 30   </p></blockquote></li><li><p>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。   </p><blockquote><p>说明：主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。   </p></blockquote></li><li><p>【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出dump 信息。   </p><blockquote><p>说明：OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。   </p></blockquote></li><li><p>【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则会带来 URL 维护不一致的问题和潜在的安全风险。   </p></li></ol><p>五、安全规约   </p><ol><li><p>【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。   </p><blockquote><p>说明：防止没有做水平权限校验就可随意访问、操作别人的数据，比如查看、修改别人的订单。   </p></blockquote></li><li><p>【强制】用户敏感数据禁止直接展示，必须对展示数据脱敏。   </p><blockquote><p>说明：查看个人手机号码会显示成:158<em>**</em>9119，隐藏中间 4 位，防止隐私泄露。   </p></blockquote></li><li><p>【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，  禁止字符串拼接 SQL 访问数据库。   </p></li><li><p>【强制】用户请求传入的任何参数必须做有效性验证。   </p><blockquote><p>说明：忽略参数校验可能导致：<br>page size 过大导致内存溢出<br>恶意 order by 导致数据库慢查询<br>任意重定向<br>SQL 注入<br>反序列化注入<br>正则输入源串拒绝服务 ReDoS<br>说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的效果。 </p></blockquote></li><li><p>【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。   </p></li><li><p>【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。   </p><blockquote><p>说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。   </p></blockquote></li><li><p>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。   </p><blockquote><p>说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。   </p></blockquote></li><li><p>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。   </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-编程规约&quot;&gt;一 编程规约&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-命名规约&quot;&gt;(一) 命名规约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-常量定义&quot;&gt;(二) 常量定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三-格式规约&quot;&gt;(三) 格式规约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四-OOP规约&quot;&gt;(四) OOP规约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#五-集合处理&quot;&gt;(五) 集合处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#六-并发处理&quot;&gt;(六) 并发处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#七-控制语句&quot;&gt;(七) 控制语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#八-注释规约&quot;&gt;(八) 注释规约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#九-其它&quot;&gt;(九) 其它&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-异常日志&quot;&gt;二 异常日志&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-异常处理&quot;&gt;(一) 异常处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-日志规约&quot;&gt;(二) 日志规约&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三-MySQL规约&quot;&gt;三 MySQL规约&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-建表规约&quot;&gt;(一) 建表规约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-索引规约&quot;&gt;(二) 索引规约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三-SQL规约&quot;&gt;(三) SQL规约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四-ORM规约&quot;&gt;(四) ORM规约&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四-工程规约&quot;&gt;四 工程规约&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-应用分层&quot;&gt;(一) 应用分层&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二-二方库规约&quot;&gt;(二) 二方库规约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三-服务器规约&quot;&gt;(三) 服务器规约&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#五-安全规约&quot;&gt;五 安全规约&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="specification" scheme="http://xiongyingqi.com/tags/specification/"/>
    
      <category term="ali" scheme="http://xiongyingqi.com/tags/ali/"/>
    
  </entry>
  
  <entry>
    <title>maven记事本</title>
    <link href="http://xiongyingqi.com/2016/12/18/2016-12-19-maven-notes/"/>
    <id>http://xiongyingqi.com/2016/12/18/2016-12-19-maven-notes/</id>
    <published>2016-12-18T17:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>记录工作中经常要去爬的maven相关技术。</p><h2 id="拷贝maven依赖到target-lib下"><a href="#拷贝maven依赖到target-lib下" class="headerlink" title="拷贝maven依赖到target/lib下"></a>拷贝maven依赖到<code>target/lib</code>下</h2><pre><code class="xml">           &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;copy-dependencies&lt;/id&gt;                        &lt;phase&gt;prepare-package&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;                        &lt;/goals&gt;                        &lt;configuration&gt;                            &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;                            &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt;                            &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt;                            &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt;                        &lt;/configuration&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录工作中经常要去爬的maven相关技术。&lt;/p&gt;
&lt;h2 id=&quot;拷贝maven依赖到target-lib下&quot;&gt;&lt;a href=&quot;#拷贝maven依赖到target-lib下&quot; class=&quot;headerlink&quot; title=&quot;拷贝maven依赖到target/lib下
      
    
    </summary>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="maven" scheme="http://xiongyingqi.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>java开发者常用软件下载地址收集</title>
    <link href="http://xiongyingqi.com/2016/11/14/2016-11-14-tools-download-url/"/>
    <id>http://xiongyingqi.com/2016/11/14/2016-11-14-tools-download-url/</id>
    <published>2016-11-14T11:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>这里收藏工作中用到的下载地址，也为了防止做重复的搜索工作，同时分享给大家。<br><a id="more"></a></p><h1 id="java相关"><a href="#java相关" class="headerlink" title="java相关"></a>java相关</h1><ul><li>api<br><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/api/index.html</a></li><li>javase<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></li><li>server-jre8<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html</a></li><li>linux wget下载<ul><li>java8 <code>wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.tar.gz</code></li><li>serverjre8 <code>wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz</code></li><li>java7 <code>wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/7u80-b15/server-jre-7u80-linux-x64.tar.gz</code></li></ul></li><li>linux curl下载<ul><li>java8 <code>curl -v -j -k -L -H &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.tar.gz -o jdk-8u112-linux-x64.tar.gz</code></li><li>serverjre8 <code>curl -v -j -k -L -H &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz -o server-jre-8u131-linux-x64.tar.gz</code></li><li>java7 <code>curl -v -j -k -L -H &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/7u80-b15/server-jre-7u80-linux-x64.tar.gz -o server-jre-7u80-linux-x64.tar.gz</code></li></ul></li><li>kafka<br><a href="https://kafka.apache.org/downloads" target="_blank" rel="external">https://kafka.apache.org/downloads</a></li><li>zookeeper<br><a href="http://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="external">http://www.apache.org/dyn/closer.cgi/zookeeper/</a></li><li>maven<br><a href="http://maven.apache.org/download.cgi?Preferred=http%3A%2F%2Fmirror.bit.edu.cn%2Fapache%2F" target="_blank" rel="external">http://maven.apache.org/download.cgi?Preferred=http%3A%2F%2Fmirror.bit.edu.cn%2Fapache%2F</a></li></ul><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><ul><li>official<br><a href="https://docs.docker.com/engine/installation/linux/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/</a></li><li>aliyun<br><a href="http://mirrors.aliyun.com/help/docker-engine?spm=0.0.0.0.2Uz4uT" target="_blank" rel="external">http://mirrors.aliyun.com/help/docker-engine?spm=0.0.0.0.2Uz4uT</a></li><li>compose<br><a href="https://docs.docker.com/compose/install/" target="_blank" rel="external">https://docs.docker.com/compose/install/</a></li></ul><h1 id="database"><a href="#database" class="headerlink" title="database"></a>database</h1><ul><li>MySQL<br><a href="http://dev.mysql.com/downloads/" target="_blank" rel="external">http://dev.mysql.com/downloads/</a></li><li>MySQL  Community Server<br><a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">http://dev.mysql.com/downloads/mysql/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里收藏工作中用到的下载地址，也为了防止做重复的搜索工作，同时分享给大家。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="tool" scheme="http://xiongyingqi.com/tags/tool/"/>
    
      <category term="download" scheme="http://xiongyingqi.com/tags/download/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本命令备忘</title>
    <link href="http://xiongyingqi.com/2016/09/12/shell-notes/"/>
    <id>http://xiongyingqi.com/2016/09/12/shell-notes/</id>
    <published>2016-09-12T17:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.094Z</updated>
    
    <content type="html"><![CDATA[<p>这里收藏工作中用到的脚本，也为了防止做重复的搜索工作，同时分享给大家。<br><a id="more"></a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>初始化数组<pre><code class="shell">name = (value1 value2 ... valuen)$ A=(a b c d)$ echo ${A[@]} # 输出所有元素</code></pre></li></ul><ul><li><p>数组去重</p><pre><code class="shell">$ array=($(awk -vRS=&#39; &#39; &#39;!a[$1]++&#39; &lt;&lt;&lt; ${array[@]}))</code></pre></li><li><p>取得数组元素的个数</p><pre><code class="shell">$ echo ${#A[@]}</code></pre></li><li><p>取下标</p><pre><code class="shell">$ echo ${A[1]} # 从1开始</code></pre></li><li><p>清除元素</p><pre><code class="shell">$ unset A$ echo ${A[@]}</code></pre></li><li><p>循环取元素</p><pre><code class="shell">$ for a in ${A[@]}; do $   echo &quot;$a&quot;$ done</code></pre></li><li><p>替换</p><pre><code class="shell">$ ${A[@]/3/100}</code></pre></li></ul><h1 id="date"><a href="#date" class="headerlink" title="date"></a>date</h1><ul><li><p>获取当前日期并格式化成指定格式</p><pre><code class="shell">$ NOW=$(date +&#39;%Y-%m-%d_%H%M%S&#39;) # 2016-09-07_184914</code></pre></li><li><p>计算当前时间的时间戳</p><pre><code class="shell">$ STAMP=$(($(date +%s -d &quot;$(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&quot;))) # 1473245414</code></pre></li><li><p>计算N天之前的时间</p><pre><code class="shell"># 十天之前的日期$ TEN_DAYS_AGO=$(($(date -d &#39;-10 day&#39; &quot;+%Y%m%d%H%M%S&quot;))) #20160828185138</code></pre></li><li><p>获取xxxx年xx月的天数</p><pre><code class="shell"># 获取 2016-10 的天数$ cal 10 2016 | awk &#39;NF{out=$NF;}END{print out}&#39;</code></pre><p>输出</p><pre><code>31</code></pre></li></ul><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><ul><li>vi/vim修改只读(readonly)文件，使用sudo修改<pre><code class="shell">:w !sudo tee % &gt; /dev/null</code></pre></li></ul><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><ul><li><p>过滤数字</p><pre><code class="shell">$ echo &quot;123&quot; |awk &#39;{if($0 ~ /^[0-9]+$/) print $0;}&#39;</code></pre></li><li><p>数字求和</p><pre><code class="shell">$ cat ${FILE} | awk &#39;{sum += $1};END {printf (&quot;%d\n&quot;, sum)}&#39;</code></pre></li><li><p>截取字符串</p><pre><code class="shell">$ echo &quot;123456&quot; | awk &#39;{print substr($1,1,4)}&#39; #1234</code></pre></li><li><p>获取月份所在季度</p><pre><code class="shell">$ for q in `seq 1 12`; echo $q | awk &#39;{season_least=$1%3} {season=$1/3} {if(season_least&gt;0) season+=1} {printf(&quot;%d\n&quot;,season)}&#39;</code></pre><p>输出</p><pre><code class="shell">111222333444</code></pre></li><li><p>删除所有空格</p><pre><code class="shell">$ echo &quot;1 2  3 4&quot; | sed -e &#39;s/[[:space:]]//g &#39;</code></pre><p>输出</p><pre><code class="shell">1234</code></pre></li><li><p>替换所有的.为/</p><pre><code class="shell">$ echo &quot;com.xiongyingqi.Test&quot; | awk &#39;{gsub(/\./,&quot;/&quot;); print $0}&#39;</code></pre><p>输出</p><pre><code class="shell">com/xiongyingqi/Test</code></pre></li></ul><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><ul><li><p>去除首尾空格</p><pre><code class="shell">$ FOO_NO_EXTERNAL_SPACE=&quot;$(echo -e &quot;${FOO}&quot; | sed -e &#39;s/^[[:space:]]*//&#39; -e &#39;s/[[:space:]]*$//&#39;)&quot;</code></pre></li><li><p>删除空行</p><pre><code class="shell">$ sed &#39;/^$/d&#39; sources.list</code></pre></li></ul><h1 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h1><ul><li>统计重复数<pre><code class="shell">$ cat file | uniq -c</code></pre></li></ul><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul><li><p>寻找有指定内容的文件</p><pre><code class="shell">$ FOUND=&quot;test&quot; # 需要查找的内容$ find . | while read file; do if [ -f $file ]; then content=`cat ${file} | grep &quot;${FOUND}&quot;`; if [ -n &quot;$content&quot; ]; then echo ${file} ; fi; fi; done</code></pre></li><li><p>列举文件并用管道打包</p><pre><code class="shell">$ find . -name &quot;*.class&quot; | xargs tar cvf classes.tar</code></pre></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>我们先写一个简单的脚本，执行以后再解释各个变量的意义</p><pre><code class="shell">$ touch variable$ vi variable</code></pre><p>脚本内容如下：</p><pre><code class="shell">#!/bin/shecho &quot;number:$#&quot;echo &quot;scname:$0&quot;echo &quot;first :$1&quot;echo &quot;second:$2&quot;echo &quot;argume:$@&quot;echo &quot;show parm list:$*&quot;echo &quot;show process id:$$&quot;echo &quot;show precomm stat: $?&quot;</code></pre><p>保存退出</p><p>赋予脚本执行权限</p><pre><code class="shell">$ chmod +x variable</code></pre><p>执行脚本</p><pre><code class="shell">$ ./variable aa bb</code></pre><p>输出</p><pre><code class="shell">number:2scname:./variablefirst:aasecond:bbargume:aa bbshow parm list:aa bbshow process id:24544show precomm stat:0</code></pre><p>通过显示结果可以看到：</p><ul><li>$# 是传给脚本的参数个数</li><li>$0 是脚本本身的名字</li><li>$1 是传递给该shell脚本的第一个参数</li><li>$2 是传递给该shell脚本的第二个参数</li><li>$@ 是传给脚本的所有参数的列表</li><li>$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</li><li>$$ 是脚本运行的当前进程ID号</li><li>$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><ul><li>*amount.txt 下所有文件的第8列数字之和<blockquote><p>iconv -fgbk 为转换文件为 gbk</p></blockquote></li></ul><pre><code class="shell">ls *amount.txt | while read file; do cat ${file}; done | iconv -fgbk | awk -F &quot;\t&quot; &#39;{print $8}&#39; | awk &#39;{if($0 ~ /^[0-9]+$/) print $0;}&#39; | awk &#39;{sum += $1};END {printf (&quot;%d\n&quot;, sum)}&#39;</code></pre><ul><li>将目录下的jar文件转换为maven格式的依赖</li></ul><pre><code class="shell">#!/bin/bashfind . -name &quot;*.jar&quot; | while read jar; do    artifact=`echo ${jar} | awk &#39;{print substr($jar,1,length($jar)-4);}&#39;`    version=`echo &quot;$artifact&quot; | awk -F &#39;-&#39; &#39; { print $NF } &#39;`    if [ $version == $artifact ]; then        version=&quot;1.0&quot;    else        artifact=`echo &quot;$artifact&quot; | awk -v version=&quot;$version&quot; &#39;{print substr($1,1,index($1,version)-2)}&#39;`    fi    # find group    groupDirectory=`jar -tf $jar | grep &quot;.class&quot; | head -n 1`    last=`echo &quot;$groupDirectory&quot; | awk -F &#39;/&#39; &#39; { print $NF } &#39;`    group=`echo &quot;$groupDirectory&quot; | awk -v last=&quot;$last&quot; &#39;{print substr($1,1,index($1,last)-2)}&#39;`    # replace / to .    group=`echo $group | awk &#39;{gsub(/\//,&quot;.&quot;); print $0}&#39;`    echo &quot;        &lt;dependency&gt;            &lt;groupId&gt;${group}&lt;/groupId&gt;            &lt;artifactId&gt;${artifact}&lt;/artifactId&gt;            &lt;version&gt;${version}&lt;/version&gt;            &lt;scope&gt;system&lt;/scope&gt;            &lt;systemPath&gt;\${project.basedir}/lib/${jar}&lt;/systemPath&gt;        &lt;/dependency&gt;&quot; #&gt;&gt; &quot;dependencies.tmp&quot;done</code></pre><ul><li>查找java类所在当前目录内的jar包</li></ul><pre><code class="shell">$ FOUND=&quot;com.xiongyingqi.Test&quot; &amp;&amp; ls *.jar | while read jar; do jar tf $jar | grep `echo &quot;${FOUND}&quot; | awk &#39;{gsub(/\./,&quot;/&quot;); print $0}&#39;` | awk -v jar=&quot;$jar&quot; &#39;{if (length($1) &gt; 0) print jar}&#39;; done</code></pre><ul><li><p>将目录内的文件转换为classpath需要的参数</p><pre><code class="shell">ls lib/*.jar | xargs | awk -v d=&quot;${delete}&quot; &#39;{      str=&quot;&quot;;      is_in=0;      for(i=1;i&lt;=NF;i++){          if($i!=d){              if(is_in == 1){                  str=str&quot;:&quot;$i;              }else{                  str=str&quot;&quot;$i;                  is_in=1;              }          }      }      print str  }&#39;</code></pre></li><li><p>查找某个目录下所有的jar包里面有哪些class是冲突的shell脚本</p></li></ul><pre><code class="shell">#!bin/bashecho &quot;Find out conflict class in the given path&quot;;if [ $# != 1 ] ; then echo &quot;Usage: sh findconflictclass.sh $1 ,first param means the path you want to find,eg: sh findconflictclass.sh lib&quot;;exit 1;fifindconflictclass.shecho &quot;Please wait ...&quot;;jarpath=$1;function unjarclass(){ for i in `find $jarpath -name *.jar`; do jar -tvf &quot;$i&quot; |grep .class$ | awk &#39;{print $8}&#39; ;  # if [[ $? == 0 ]]; then echo $i; fi;  done}unjarclass 1&gt;temp.txt;echo &#39;unjar class in the given path has done&#39;;sleep 10sfunction findclassinjar(){echo -e &quot;\033[47;31m &#39;The class $1 exists in multi-place below:&#39; \033[0m&quot; ; for i in `find $2 -name *.jar`; do jar -tvf &quot;$i&quot; | grep --color -i &quot;$1&quot; ; if [[ $? == 0 ]]; then echo -e &quot;\033[33m &#39;The jar path is: $i&#39; \033[0m&quot; ; fi; done}sort temp.txt | uniq -d | cat | while read line; do a=$line; findclassinjar $a $jarpath;donerm -rf temp.txt</code></pre><ul><li>替换字符串</li></ul><pre><code class="shell">$ data=&quot;a&quot; &amp;&amp; newdata=&quot;c&quot; &amp;&amp; echo &quot;aaabbba&quot;|awk -v var=${1} -v var1=${data} -v var2=${newdata} &#39;$0 ~ var {gsub(var1,var2); print}&#39;</code></pre><p>输出</p><pre><code class="shell">cccbbbc</code></pre><ul><li>文件内容替换<br>替换<code>当前目录下的所有文件</code>内容中的<code>hello</code>为<code>helloworld</code></li></ul><pre><code class="shell">find . -type f | while read file; do sed -i &#39;s/hello/helloworld/g&#39; $file;done</code></pre><ul><li>测试curl</li></ul><pre><code class="shell">$ size=1000;i=0; while [ $i -lt $size ];do i=$((i+1)); curl &quot;http://baidu.com&quot; &amp; done</code></pre><ul><li>获取从开始日期到结束日期所经历过的季度</li></ul><pre><code class="shell">FROM_DATE=&quot;$1&quot;TO_DATE=&quot;$2&quot;FROM_SEASON=`echo &quot;${FROM_DATE}&quot; | awk -F &quot;-&quot; &#39;{print $2}&#39;| awk &#39;{season_least=$1%3} {season=$1/3} {if(season_least&gt;0) season+=1} {printf(&quot;%d\n&quot;,season)}&#39;`TO_SEASON=`echo &quot;${TO_DATE}&quot; | awk -F &quot;-&quot; &#39;{print $2}&#39;| awk &#39;{season_least=$1%3} {season=$1/3} {if(season_least&gt;0) season+=1} {printf(&quot;%d\n&quot;,season)}&#39;`echo &quot;FROM_SEASON: ${FROM_SEASON}&quot;echo &quot;TO_SEASON: ${TO_SEASON}&quot;FROM_YEAR=`echo &quot;${FROM_DATE}&quot; | awk -F &quot;-&quot; &#39;{print $1}&#39;`TO_YEAR=`echo &quot;${TO_DATE}&quot; | awk -F &quot;-&quot; &#39;{print $1}&#39;`year_season_file=&quot;year_season.tmp&quot;if [ -f ${year_season_file} ];then    echo &quot;delete file: ${year_season_file}&quot;    rm -f ${year_season_file}fiif [ ${FROM_YEAR} -eq ${TO_YEAR} ]; then    for season in `seq ${FROM_SEASON} ${TO_SEASON}`; do        echo &quot;${FROM_YEAR}Q${season}&quot; &gt;&gt; ${year_season_file}    doneelse    for season in `seq ${FROM_SEASON} 4`; do        echo &quot;${FROM_YEAR}Q${season}&quot; &gt;&gt; ${year_season_file}    done    #FROM_YEAR    if [ $((TO_YEAR-FROM_YEAR)) -ge 2 ]; then        for year in `seq $((FROM_YEAR+1)) $((TO_YEAR-1))`; do            for season in `seq 1 4`; do                echo &quot;${year}Q${season}&quot; &gt;&gt; ${year_season_file}            done        done    fi    for season in `seq 1 ${TO_SEASON}`; do        echo &quot;${TO_YEAR}Q${season}&quot; &gt;&gt; ${year_season_file}    doneficat ${year_season_file}</code></pre><ul><li>多线程访问</li></ul><pre><code class="shell">for ((i=0;i&lt;10;)); do     for j in `seq 1 100`; do         curl &quot;http://baidu.com&quot; &amp;     done;     wait;     i=$((i+1)); done</code></pre><ul><li>按列合并</li></ul><pre><code class="shell">cat filtsoort | awk &#39;{sum[$1]+=$2}END{for (i in sum) print i&quot; &quot;sum[i]}&#39;</code></pre><ul><li>转换编码</li></ul><pre><code class="shell">find . -name &quot;*.java&quot; | while read file; do iconv -f gbk -t utf-8 $file &gt; ${file}.bak; mv -f ${file}.bak $file; done</code></pre><ul><li><p>word转换为markdown<br>需要先安装<code>w2m</code>: <a href="https://github.com/benbalter/word-to-markdown" target="_blank" rel="external">benbalter/word-to-markdown</a></p><pre><code class="shell">find doc -name &quot;*.doc&quot; | while read file; do   folder_tmp=&quot;markdown/$file&quot;;  folder=${folder_tmp%/*};  target_file=&quot;${folder_tmp%%.*}&quot;.md  mkdir -p $folder;  w2m $file &gt; $target_file; done</code></pre></li><li><p>移除base64图像</p><pre><code class="shell">sed -i &#39;s-\!\[\](data:image\/\*;base64,.*)--g&#39; $file</code></pre></li><li><p>判断是否为asccii字符串（英文字符）</p><pre><code class="shell">echo &quot;呵呵&quot; | awk &#39;{ print (length($0)&gt;NF)}&#39; #1</code></pre></li><li><p>输出带颜色的字符<br>shell脚本中echo显示内容带颜色显示,echo显示带颜色，需要使用参数-e<br>格式如下：</p></li></ul><pre><code class="shell">echo -e &quot;\033[字背景颜色；文字颜色m字符串\033[0m&quot;</code></pre><p>例如： </p><pre><code class="shell">echo -e &quot;\033[41;36m something here \033[0m&quot;</code></pre><p>其中41的位置代表底色， 36的位置是代表字的颜色 </p><blockquote><p>注：<br>1、字背景颜色和文字颜色之间是英文的””<br>2、文字颜色后面有个m<br>3、字符串前后可以没有空格，如果有的话，输出也是同样有空格 </p></blockquote><p>下面是相应的字和背景颜色，可以自己来尝试找出不同颜色搭配<br>例 </p><pre><code class="shell">echo -e &quot;\033[31m 红色字 \033[0m&quot;echo -e &quot;\033[34m 黄色字 \033[0m&quot;echo -e &quot;\033[41;33m 红底黄字 \033[0m&quot;echo -e &quot;\033[41;37m 红底白字 \033[0m&quot;</code></pre><p>字颜色：30—–37 </p><pre><code class="shell">echo -e &quot;\033[30m 黑色字 \033[0m&quot;echo -e &quot;\033[31m 红色字 \033[0m&quot;echo -e &quot;\033[32m 绿色字 \033[0m&quot;echo -e &quot;\033[33m 黄色字 \033[0m&quot;echo -e &quot;\033[34m 蓝色字 \033[0m&quot;echo -e &quot;\033[35m 紫色字 \033[0m&quot;echo -e &quot;\033[36m 天蓝字 \033[0m&quot;echo -e &quot;\033[37m 白色字 \033[0m&quot;</code></pre><p>字背景颜色范围：40—–47 </p><pre><code class="shell">echo -e &quot;\033[40;37m 黑底白字 \033[0m&quot;echo -e &quot;\033[41;37m 红底白字 \033[0m&quot;echo -e &quot;\033[42;37m 绿底白字 \033[0m&quot;echo -e &quot;\033[43;37m 黄底白字 \033[0m&quot;echo -e &quot;\033[44;37m 蓝底白字 \033[0m&quot;echo -e &quot;\033[45;37m 紫底白字 \033[0m&quot;echo -e &quot;\033[46;37m 天蓝底白字 \033[0m&quot;echo -e &quot;\033[47;30m 白底黑字 \033[0m&quot;</code></pre><p>最后面控制选项说明 </p><ul><li>\33[0m 关闭所有属性 </li><li>\33[1m 设置高亮度 </li><li>\33[4m 下划线 </li><li>\33[5m 闪烁 </li><li>\33[7m 反显 </li><li>\33[8m 消隐 </li><li>\33[30m — \33[37m 设置前景色 </li><li>\33[40m — \33[47m 设置背景色 </li><li>\33[nA 光标上移n行 </li><li>\33[nB 光标下移n行 </li><li>\33[nC 光标右移n行 </li><li>\33[nD 光标左移n行 </li><li>\33[y;xH设置光标位置 </li><li>\33[2J 清屏 </li><li>\33[K 清除从光标到行尾的内容 </li><li>\33[s 保存光标位置 </li><li>\33[u 恢复光标位置 </li><li>\33[?25l 隐藏光标 </li><li>\33[?25h 显示光标 </li></ul><pre><code class="shell">function echoGreen(){    echo -e &quot;\033[32m$1\033[0m&quot;}function echoRed(){    echo -e &quot;\033[31m$1\033[0m&quot;}function echoYellow(){    echo -e &quot;\033[33m$1\033[0m&quot;}</code></pre><ul><li>从第二行开始显示<pre><code class="shell">cat file | awk &#39;NR&gt;2{print p}{p=$0}&#39;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里收藏工作中用到的脚本，也为了防止做重复的搜索工作，同时分享给大家。&lt;br&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://xiongyingqi.com/tags/shell/"/>
    
      <category term="vim" scheme="http://xiongyingqi.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>java分段锁示例</title>
    <link href="http://xiongyingqi.com/2016/04/18/java-multiple-segment-lock/"/>
    <id>http://xiongyingqi.com/2016/04/18/java-multiple-segment-lock/</id>
    <published>2016-04-18T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>读ConcurrentHashMap的时候，我们遇到的一个很大的概念就是<code>Segment</code>（java8之后只有在调用writeObject方法的方法的时候才会用到segment），该类继承了<code>ReentrantLock</code>，用于实现分段锁（乐观锁）。处于心痒痒的目的，我也尝试写了个简陋版的分段锁。</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>该Demo实现的比较简单：根据key获取或者创建Lock（获取锁的时候使用<code>double check</code>），然后使用该锁来同步put或者read（ConcurrentHashMap的读操作使用的volatile，这里不深入）。不足之处还请指正~</p><h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>java实现： <a href="https://github.com/blademainer/java-demo/blob/master/src/main/java/com/xiongyingqi/concurrent/MultipleSegmentLock.java" target="_blank" rel="external">github</a></p><a id="more"></a><pre><code class="java">package com.xiongyingqi.concurrent;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author xiongyingqi * @version 2016-04-18 16:51 */public class MultipleSegmentLock {    private Map&lt;String, ReentrantLock&gt; lockMap = new ConcurrentHashMap&lt;String, ReentrantLock&gt;();    public void write(String key, String value) {        Lock lock = checkLock(key);        lock.lock();        try {            System.out.println(&quot;writing... &quot; + key + &quot;=&quot; + value);            try {                //                Random random = new Random();                //                long time = random.nextInt(10) + 10;                //                Thread.sleep(time);                Thread.sleep(10L);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(&quot;write complete... &quot; + key + &quot;=&quot; + value);        } finally {            lock.unlock();        }    }    public void read(String key) {        Lock lock = checkLock(key);        lock.lock();        try {            System.out.println(&quot;reading... &quot; + key);            try {                Thread.sleep(10L);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(&quot;read complete... &quot; + key);        } finally {            lock.unlock();        }    }    /**     * Getting the lock of the key. Create a {@link ReentrantLock} when not exists.     * &lt;p&gt;Implements with double check&lt;/p&gt;     *     * @param key Segment by the key     * @return {@link ReentrantLock}     */    private Lock checkLock(String key) {        ReentrantLock reentrantLock = lockMap.get(key);        if (reentrantLock == null) {            synchronized (this) {                reentrantLock = lockMap.get(key);                if (reentrantLock == null) {                    reentrantLock = new ReentrantLock();                    System.out.println(                            &quot;lock for &quot; + key + &quot; not exists! so create a lock: &quot; + reentrantLock);                    lockMap.put(key, reentrantLock);                    return reentrantLock;                }                return reentrantLock;            }        }        return reentrantLock;    }    public static void main(String[] args) {        MultipleSegmentLock multipleSegmentLock = new MultipleSegmentLock();        new Thread(() -&gt; {            for (int i = 0; i &lt; 100; i++) {                multipleSegmentLock.write(&quot;key&quot;,                        &quot;&quot; + i); // synchronous with &#39;key&#39; and asynchronous with &#39;key2&#39;            }        }).start();        new Thread(() -&gt; {            for (int i = 100; i &lt; 200; i++) {                multipleSegmentLock.write(&quot;key&quot;,                        &quot;&quot; + i); // synchronous with &#39;key&#39; and asynchronous with &#39;key2&#39;            }        }).start();        new Thread(() -&gt; {            for (int i = 0; i &lt; 100; i++) {                multipleSegmentLock.write(&quot;key2&quot;,                        &quot;&quot; + i); // synchronous with &#39;key2&#39; and asynchronous with &#39;key&#39;            }        }).start();        new Thread(() -&gt; {            for (int i = 100; i &lt; 200; i++) {                multipleSegmentLock.write(&quot;key2&quot;,                        &quot;&quot; + i); // synchronous with &#39;key2&#39; and asynchronous with &#39;key&#39;            }        }).start();        new Thread(() -&gt; {            for (int i = 0; i &lt; 100; i++) {                multipleSegmentLock.read(&quot;key&quot;);            }        }).start();        // Console out may be:        // ----------------------------------------------------        //lock for key not exists! so create a lock: null        //lock for key2 not exists! so create a lock: null        //writing... key=0        //writing... key2=0        //write complete... key=0        //write complete... key2=0        //writing... key=1        //writing... key2=1        //write complete... key=1        //write complete... key2=1        //writing... key2=2        //writing... key=2        //write complete... key2=2        //write complete... key=2        //writing... key2=3        //writing... key=3        //write complete... key2=3        //write complete... key=3        //... ...        //reading... key        //write complete... key2=49        //read complete... key        //reading... key        //writing... key2=50        //read complete... key        //write complete... key2=50        //reading... key        //writing... key2=51        //read complete... key        //write complete... key2=51        //reading... key        //writing... key2=109        //read complete... key        //write complete... key2=109        //reading... key        //writing... key2=110        //read complete... key        //... ...        //writing... key=194        //write complete... key=194        //writing... key=195        //write complete... key=195        //writing... key=196        //write complete... key=196        //writing... key=197        //write complete... key=197        //writing... key=198        //write complete... key=198        //writing... key=199        //write complete... key=199        // ----------------------------------------------------    }}</code></pre>]]></content>
    
    <summary type="html">
    
      java分段锁最经典的例子是ConcurrentHashMap，我们也来做做实验。
    
    </summary>
    
      <category term="java" scheme="http://xiongyingqi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="spring" scheme="http://xiongyingqi.com/tags/spring/"/>
    
      <category term="segment" scheme="http://xiongyingqi.com/tags/segment/"/>
    
      <category term="lock" scheme="http://xiongyingqi.com/tags/lock/"/>
    
      <category term="ReentrantLock" scheme="http://xiongyingqi.com/tags/ReentrantLock/"/>
    
      <category term="锁" scheme="http://xiongyingqi.com/tags/%E9%94%81/"/>
    
      <category term="分段锁" scheme="http://xiongyingqi.com/tags/%E5%88%86%E6%AE%B5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Jackson解析json为指定泛型的集合</title>
    <link href="http://xiongyingqi.com/2016/03/29/jackson-deserialize-collection/"/>
    <id>http://xiongyingqi.com/2016/03/29/jackson-deserialize-collection/</id>
    <published>2016-03-29T11:22:49.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在日常开发中，当使用ObjectMapper进行解析json时，我们时常需要将json解析成我们指定泛型的集合类型<code>Collection&lt;type&gt;</code>。<br>但是如果直接使用<code>objectMapper.readValue(json, Collection.class)</code>的话，那么就会解析为<code>Collection&lt;Map&gt;</code>的类型，这个明显不是我们想要的。  </p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>在jackson内，如果要反序列化为Collection或者Map，我们可以使用  </p><ul><li><code>CollectionType construct = CollectionType.construct(LinkedList.class, SimpleType.construct(clazz));</code> </li><li><code>MapType construct = MapType.construct(HashMap.class, SimpleType.construct(keyType), SimpleType.construct(valueType))</code></li></ul><a id="more"></a><pre><code class="java">package com.xiongyingqi.json;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.CollectionType;import com.fasterxml.jackson.databind.type.MapType;import com.fasterxml.jackson.databind.type.SimpleType;import java.io.IOException;import java.util.*;/** * @author xiongyingqi * @version 2016-03-29 11:23 */public class JacksonDemo {    public static ObjectMapper getMapper() {        return new ObjectMapper();    }    public String writeAsString(Object o) throws JsonProcessingException {        ObjectMapper mapper = new ObjectMapper();        return mapper.writeValueAsString(o);    }    /**     * 获取反序列化的集合类型JavaType     *     * @param clazz 元素类型     * @return {@link JavaType}     */    public static JavaType getListType(Class&lt;?&gt; clazz) {        CollectionType construct = CollectionType                .construct(LinkedList.class, SimpleType.construct(clazz));        return construct;    }    /**     * 获取反序列化的map类型JavaType     *     * @param keyType   键类型     * @param valueType 值类型     * @return {@link JavaType}     */    public static JavaType getMapType(Class&lt;?&gt; keyType, Class&lt;?&gt; valueType) {        MapType construct = MapType.construct(HashMap.class, SimpleType.construct(keyType),                SimpleType.construct(valueType));        return construct;    }    public static void main(String[] args) throws IOException {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;hello&quot;);        list.add(&quot;world&quot;);        list.add(&quot;!&quot;);        JacksonDemo jacksonDemo = new JacksonDemo();        String listJson = jacksonDemo.writeAsString(list);        System.out.println(listJson);        JavaType listType = getListType(String.class);        ObjectMapper mapper = getMapper();        List&lt;String&gt; result = mapper.readValue(listJson, listType);        System.out.println(result);        System.out.println(result.getClass()); // LinkedList        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        map.put(&quot;one&quot;, &quot;hello&quot;);        map.put(&quot;two&quot;, &quot;world&quot;);        String mapJson = jacksonDemo.writeAsString(map);        System.out.println(mapJson);        JavaType mapType = getMapType(String.class,String.class);        Map&lt;String, String&gt; result2 = mapper.readValue(mapJson, mapType);        System.out.println(result2);        System.out.println(result2.getClass()); // HashMap    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在日常开发中，当使用ObjectMapper进行解析json时，我们时常需要将json解析成我们指定泛型的集合类型&lt;code&gt;Collection&amp;lt;type&amp;gt;&lt;/code&gt;。&lt;br&gt;但是如果直接使用&lt;code&gt;objectMapper.readValue(json, Collection.class)&lt;/code&gt;的话，那么就会解析为&lt;code&gt;Collection&amp;lt;Map&amp;gt;&lt;/code&gt;的类型，这个明显不是我们想要的。  &lt;/p&gt;
&lt;h1 id=&quot;方案&quot;&gt;&lt;a href=&quot;#方案&quot; class=&quot;headerlink&quot; title=&quot;方案&quot;&gt;&lt;/a&gt;方案&lt;/h1&gt;&lt;p&gt;在jackson内，如果要反序列化为Collection或者Map，我们可以使用  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CollectionType construct = CollectionType.construct(LinkedList.class, SimpleType.construct(clazz));&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;MapType construct = MapType.construct(HashMap.class, SimpleType.construct(keyType), SimpleType.construct(valueType))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="jackson" scheme="http://xiongyingqi.com/tags/jackson/"/>
    
      <category term="fasterxml" scheme="http://xiongyingqi.com/tags/fasterxml/"/>
    
      <category term="collection" scheme="http://xiongyingqi.com/tags/collection/"/>
    
      <category term="deserialize" scheme="http://xiongyingqi.com/tags/deserialize/"/>
    
  </entry>
  
  <entry>
    <title>scala根据Class获取单例（孤立）对象</title>
    <link href="http://xiongyingqi.com/2015/10/30/scala-object-reflect-get/"/>
    <id>http://xiongyingqi.com/2015/10/30/scala-object-reflect-get/</id>
    <published>2015-10-30T17:09:19.000Z</published>
    <updated>2017-11-02T08:39:14.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h1><p>在scala开发过程中，有需要使用Class获取scala单例（孤立）对象的需求，但是直接使用Class.newInstance()是无法获取单例对象的。</p><h1 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h1><p>google之后，在一篇博客：<a href="http://blog.csdn.net/zhangjg_blog/article/details/23376465" target="_blank" rel="external">http://blog.csdn.net/zhangjg_blog/article/details/23376465</a> 其中有一个例子：</p><pre><code class="scala">object  Test {    val a = &quot;a string&quot;;    def printString = println(a)}</code></pre><p>编译之后可以看到有两个class文件：</p><blockquote><p>Test$.class<br>Test.class</p></blockquote><p>也就是说， 这个孤立对象也被编译成一个同名类Test 。 除此之外， 还有一个叫做Test$的类， 这个以$结尾的类就是所谓的虚构类（synthetic class， 《Scala编程》中将之翻译为虚构类） 。<br><a id="more"></a></p><h2 id="单例对象原理"><a href="#单例对象原理" class="headerlink" title="单例对象原理"></a>单例对象原理</h2><p>下面使用javap反编译Test.class , 得到如下结果（去掉了常量池等信息）：</p><pre><code class="java">public final class Test  SourceFile: &quot;Test.scala&quot;  RuntimeVisibleAnnotations:    0: #6(#7=s#8)    ScalaSig: length = 0x3     05 00 00  minor version: 0  major version: 50  flags: ACC_PUBLIC, ACC_FINAL, ACC_SUPER{  public static void printString();    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=1, locals=0, args_size=0         0: getstatic     #16                 // Field Test$.MODULE$:LTest$;         3: invokevirtual #18                 // Method Test$.printString:()V         6: return  public static java.lang.String a();    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=1, locals=0, args_size=0         0: getstatic     #16                 // Field Test$.MODULE$:LTest$;         3: invokevirtual #22                 // Method Test$.a:()Ljava/lang/String;         6: areturn}</code></pre><p>由反编译的结果可以看出：</p><blockquote><p>源码中的属性a对应一个静态的同名方法a()<br>源码中的方法printString也对应一个静态的同名方法printString()<br>静态方法a()调用Test$类中的静态字段MODULE$的a方法<br>静态方法printString()调用Test$类中的静态字段MODULE$的printString方法</p></blockquote><p>如果用java来描述的话， Test类的逻辑是这样的：</p><pre><code class="java">public final class Test{    public static java.lang.String a(){        return Test$.MODULE$.a()    }    public static void printString(){        Test$.MODULE$.printString()    }}</code></pre><p>下面再看Test类的虚构类Test$的javap反编译结果：</p><pre><code class="java">public final class Test$  SourceFile: &quot;Test.scala&quot;    Scala: length = 0x0  minor version: 0  major version: 50  flags: ACC_PUBLIC, ACC_FINAL, ACC_SUPER{  public static final Test$ MODULE$;    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL  private final java.lang.String a;    flags: ACC_PRIVATE, ACC_FINAL  public static {};    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=1, locals=0, args_size=0         0: new           #2                  // class Test$         3: invokespecial #12                 // Method &quot;&lt;init&gt;&quot;:()V         6: return  public java.lang.String a();    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: getfield      #17                 // Field a:Ljava/lang/String;         4: areturn  public void printString();    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #24                 // Field scala/Predef$.MODULE$:Lscala/Predef$;         3: aload_0         4: invokevirtual #26                 // Method a:()Ljava/lang/String;         7: invokevirtual #30                 // Method scala/Predef$.println:(Ljava/lang/Object;)V        10: return  private Test$();    flags: ACC_PRIVATE    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #31                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: putstatic     #33                 // Field MODULE$:LTest$;         8: aload_0         9: ldc           #35                 // String a string        11: putfield      #17                 // Field a:Ljava/lang/String;        14: return}</code></pre><h3 id="看一下这个类里的内容："><a href="#看一下这个类里的内容：" class="headerlink" title="看一下这个类里的内容："></a>看一下这个类里的内容：</h3><p> 首先， 该类中有一个常量字段MODULE$， 它的类型就是当前的虚构类Test$ 。</p><pre><code class="java">public static final Test$ MODULE$;    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</code></pre><p>编译器在Test$中默认添加了静态初始化方法， 用于对静态字段MODULE$初始化：</p><pre><code class="java"> public static {};    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=1, locals=0, args_size=0         0: new           #2                  // class Test$         3: invokespecial #12                 // Method &quot;&lt;init&gt;&quot;:()V         6: return</code></pre><p>源码中的字段a在Test$中对应一个非静态的字段a ， 由于源码中的a是val的， 所以在Test$中对应的a字段是final的</p><pre><code class="java">  private final java.lang.String a;    flags: ACC_PRIVATE, ACC_FINAL</code></pre><p>在Test$中还有一个成员方法a()与字段a对应， 这个方法的逻辑是返回a的值</p><pre><code class="java">  public java.lang.String a();    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: getfield      #17                 // Field a:Ljava/lang/String;         4: areturn</code></pre><p>源码中的方法printString对应Test$中的printString方法。 这个方法的逻辑是调用方法a()获取字段a的值， 并打印a的值。</p><pre><code class="java">  public void printString();    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #24                 // Field scala/Predef$.MODULE$:Lscala/Predef$;         3: aload_0         4: invokevirtual #26                 // Method a:()Ljava/lang/String;         7: invokevirtual #30                 // Method scala/Predef$.println:(Ljava/lang/Object;)V        10: return</code></pre><p>此外， 编译器在Test$中还加入默认的构造方法， 不过这个构造方法是私有的。 无法为外部调用。如下：</p><pre><code class="java">  private Test$();    flags: ACC_PRIVATE    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #31                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: putstatic     #33                 // Field MODULE$:LTest$;         8: aload_0         9: ldc           #35                 // String a string        11: putfield      #17                 // Field a:Ljava/lang/String;        14: return</code></pre><p>如果用java代码描述的话，Test$的逻辑是这样的：</p><pre><code class="java">public final class Test${    public static final Test$ MODULE$ = new Test$();    private final String a = &quot;a string&quot;;     public String a(){        return a;     }     public void printString(){        println(a());     }     private Test$(){}}</code></pre><p>由此可见</p><blockquote><p>这个虚构类Test$是单例的。<br>一方面， 这个类是编译器默认生成的，在Scala代码中无法访问到。<br>另一方面， Test$构造器私有了， 只在内部创建了一个对象赋给了静态引用MODULE$ 。 </p></blockquote><p>所以， 在Scala里面称用object关键字修饰的对象是单例对象， 在实现的角度上看， 并不是十分确切。 虽然称之为对象， 但是编译器确实为他生成了一个类， 如上面例子中的object Test ， 编译器确实生成了类Test。 但是这个类中只有静态方法， 即使是一个Scala中的字段， 也对应一个静态方法， 如上例中的字段a 。 这个类中的静态方法会访问虚构类Test$中的静态成员Test$ MODULE$ ，使用这个对象可以调用Test$中的其他成员方法，Test$中的成员和源码中的成员相对应， 只是会为源码中的字段添加同名方法。 主要的处理逻辑实际上是在虚构类Test$中完成的， Test类只是作为一个入口。</p><p>下面是看一下Scala是如何实现对单例对象的调用的。 首先写一个Scala的入口类：</p><pre><code class="scala">object Main {  //scala main   def main(args : Array[String]){    Test.printString  }}</code></pre><p>相同的原理， 入口类Main也是单例对象， 实现原理和Test是相同的。 大部分的逻辑都在虚构类Main$中的成员方法main中实现的。反编译 Main$后的结果如下：</p><pre><code class="java">public final class Main$  SourceFile: &quot;Main.scala&quot;    Scala: length = 0x0  minor version: 0  major version: 50  flags: ACC_PUBLIC, ACC_FINAL, ACC_SUPER{  public static final Main$ MODULE$;    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL  public static {};    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=1, locals=0, args_size=0         0: new           #2                  // class Main$         3: invokespecial #12                 // Method &quot;&lt;init&gt;&quot;:()V         6: return  public void main(java.lang.String[]);    flags: ACC_PUBLIC    Code:      stack=1, locals=2, args_size=2         0: getstatic     #19                 // Field Test$.MODULE$:LTest$;         3: invokevirtual #22                 // Method Test$.printString:()V         6: return  private Main$();    flags: ACC_PRIVATE    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #26                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: putstatic     #28                 // Field MODULE$:LMain$;         8: return}</code></pre><p>用Java代码实现如下：</p><pre><code class="java">public final class Main${    public static final Main$ MODULE$ = new Main$();    public void main(String[] args){        Test$.MODULE$.printString();    }       private Main$(){}}</code></pre><p>由此可见， 在Main$中的成员方法main中， 直接调用了Test$.MODULE$.printString()方法， 而绕过了Test类， 这也是合理的， 因为只有Test$才处理相关逻辑。</p><p>而Main.class用java代码表示如下：</p><pre><code class="java">public final class Main{    public static void main(String[] args){        Main$.MODULE$.main(args);    }}</code></pre><p>做一下总结：</p><blockquote><p>Main.class提供JVM的入口函数， 在入口函数中调用Main$的成员方法main， 而Main$的成员方法main又调用了Test$的成员方法printString来处理相关逻辑， 即打印字符串。 </p></blockquote><p>单例对象的调用方式如下图所示：</p><p><img src="/images/post/scala-invoke-tree.png" alt=""></p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>根据上面的scala单例原理说明，我们可以知道，单例对象的类名是以<strong>$</strong>结束的，并且单例对象是在类定义下面的<strong>MODULE$</strong>字段下。因此，我们只需判断Class是不是以<strong>$</strong>结束，并且在此类下获取<strong>MODULE$</strong>字段值即可</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>ReflectionUtil.scala</p><pre><code class="scala">/** * 反射工具 * @author  &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;qi&lt;/a&gt; * @version 2015-10-21 21:01 */object ReflectionUtil {  val SINGLETON_END_NAME = &quot;$&quot;  val SINGLETON_FIELD_NAME = &quot;MODULE$&quot;  /**   * 根据class获取单例对象（必须是object关键字）   * @param clazz Class   * @tparam T 泛型   * @return T   * @see http://blog.csdn.net/zhangjg_blog/article/details/23376465   */  def getSingleton[T](clazz: Class[T]): Option[T] = {    if (!clazz.getSimpleName.endsWith(SINGLETON_END_NAME)) {      println(&quot;class name not end with: &#39;&quot; + SINGLETON_END_NAME + &quot;&#39;, it&#39;s not a singleton object!&quot; +        &quot;Must declared with &#39;object&#39;. e.g., object A {}&quot;)      return None    }    val field = clazz.getDeclaredField(SINGLETON_FIELD_NAME)    if (field == null) {      return None    }    val fieldType = field.getType    if (!fieldType.equals(clazz)) {      println(&quot;fieldType: &quot; + fieldType + &quot; not equals &quot; + clazz)      return None    }    val module: T = field.get(null).asInstanceOf[T]    Some(module)  }  /**   * test   * @param args   */  def main(args: Array[String]) {    val o = getSingleton(ReflectionUtil.getClass)    println(s&quot;ReflectionUtil getSingleton(ReflectionUtil.getClass) =========== ${o.get}&quot;)    println(s&quot;ReflectionUtil =========== $ReflectionUtil&quot;)    assert(getSingleton(ReflectionUtil.getClass).get == ReflectionUtil)  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发中遇到的问题&quot;&gt;&lt;a href=&quot;#开发中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;开发中遇到的问题&quot;&gt;&lt;/a&gt;开发中遇到的问题&lt;/h1&gt;&lt;p&gt;在scala开发过程中，有需要使用Class获取scala单例（孤立）对象的需求，但是直接使用Class.newInstance()是无法获取单例对象的。&lt;/p&gt;
&lt;h1 id=&quot;发现&quot;&gt;&lt;a href=&quot;#发现&quot; class=&quot;headerlink&quot; title=&quot;发现&quot;&gt;&lt;/a&gt;发现&lt;/h1&gt;&lt;p&gt;google之后，在一篇博客：&lt;a href=&quot;http://blog.csdn.net/zhangjg_blog/article/details/23376465&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/zhangjg_blog/article/details/23376465&lt;/a&gt; 其中有一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object  Test {
    val a = &amp;quot;a string&amp;quot;;
    def printString = println(a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译之后可以看到有两个class文件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Test$.class&lt;br&gt;Test.class&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说， 这个孤立对象也被编译成一个同名类Test 。 除此之外， 还有一个叫做Test$的类， 这个以$结尾的类就是所谓的虚构类（synthetic class， 《Scala编程》中将之翻译为虚构类） 。&lt;br&gt;
    
    </summary>
    
    
      <category term="scala" scheme="http://xiongyingqi.com/tags/scala/"/>
    
      <category term="object" scheme="http://xiongyingqi.com/tags/object/"/>
    
      <category term="reflect" scheme="http://xiongyingqi.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>最终版解决方案：json循环问题（使用javassist增强）：Spring MVC中使用jackson的MixInAnnotations方法动态过滤JSON字段</title>
    <link href="http://xiongyingqi.com/2015/10/14/2014-06-30-spring-mvc-jackson-enhance/"/>
    <id>http://xiongyingqi.com/2015/10/14/2014-06-30-spring-mvc-jackson-enhance/</id>
    <published>2015-10-14T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>项目使用SpringMVC框架，并用jackson库处理JSON和POJO的转换。在POJO转化成JSON时，有些属性我们不需要输出或者有些属性循环引用会造成无法输出。</p><ul><li>例如：实体User其中包括用户名、密码、邮箱等，但是我们在输出用户信息不希望输出密码、邮箱信息;</li><li>例如：实体user和department是多对一的关系，user内保存着department的信息，那么json输出时会导致这两个实体数据的循环输出;</li></ul><p>jackson默认可以使用JsonIgnoreProperties接口来定义要过滤的属性,然后使用<code>ObjectMapper#addMixInAnnotations</code>来设置对应实体对应的JsonIgnoreProperties接口,这样就能达到过滤的目的。可是这样很不爽,因为如果你对n个实体对应有m种过滤需求就至少要建n*m个JsonIgnoreProperties接口。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="主要逻辑如下图"><a href="#主要逻辑如下图" class="headerlink" title="主要逻辑如下图"></a>主要逻辑如下图</h2><p><img src="/images/post/jackson-logic.jpg"></p><h2 id="大致处理流程"><a href="#大致处理流程" class="headerlink" title="大致处理流程:"></a>大致处理流程:</h2><ul><li>使用自定义注解controller方法</li><li>然后定义aop捕获所有controller方法</li><li>当aop捕获到controller方法时调用JavassistFilterPropertyHandler#filterProperties方法</li><li>filterProperties读取注解并根据自定义注解使用javassist创建JsonIgnoreProperties临时实现类(同时缓存到map内,下次可直接取出)并存入当前线程内(ThreadJacksonMixInHolder, 使用threadlocal实现),</li><li>在springmvc输出json的类内自定义ObjectMapper, 从当前线程内取出JsonIgnoreProperties临时类, 调用ObjectMapper# addMixInAnnotations使之起效</li><li>最后使用ObjectMapper输出</li></ul><h1 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h1><h2 id="定义aop-用来捕获springmvc的controller方法"><a href="#定义aop-用来捕获springmvc的controller方法" class="headerlink" title="定义aop, 用来捕获springmvc的controller方法"></a>定义aop, 用来捕获springmvc的controller方法</h2><pre><code class="java">package com.xiongyingqi.json.filter.aop;import com.xiongyingqi.jackson.FilterPropertyHandler;import com.xiongyingqi.jackson.impl.JavassistFilterPropertyHandler;import org.apache.log4j.Logger;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import java.lang.reflect.Method;/** * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; * @version 2013-9-27 下午5:41:12 */@Aspectpublic class IgnorePropertyAspect {    public static final Logger LOGGER = Logger.getLogger(IgnorePropertyAspect.class);    @Pointcut(&quot;execution(* com.kingray.web.*.*(..))&quot;)    private void anyMethod() {    }    @Around(&quot;anyMethod()&quot;)    public Object around(ProceedingJoinPoint pjp) throws Throwable {        Object returnVal = pjp.proceed(); // 返回源结果        try {            FilterPropertyHandler filterPropertyHandler = new JavassistFilterPropertyHandler(true);            Method method = ((MethodSignature) pjp.getSignature()).getMethod();            returnVal = filterPropertyHandler.filterProperties(method, returnVal);        } catch (Exception e) {            LOGGER.error(e);            e.printStackTrace();        }        return returnVal;    }    @AfterThrowing(pointcut = &quot;anyMethod()&quot;, throwing = &quot;e&quot;)    public void doAfterThrowing(Exception e) {        System.out.println(&quot; -------- AfterThrowing -------- &quot;);    }}</code></pre><h2 id="spring配置"><a href="#spring配置" class="headerlink" title="spring配置"></a>spring配置</h2><pre><code class="xml">&lt;!-- 启动mvc对aop的支持,使用aspectj代理 --&gt;&lt;aop:aspectj-autoproxyproxy-target-class=&quot;true&quot; /&gt;&lt;beanid=&quot;ignorePropertyAspect&quot; class=&quot;com.xiongyingqi.json.filter.aop.IgnorePropertyAspect&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="配置spring-mvc的messageconverter"><a href="#配置spring-mvc的messageconverter" class="headerlink" title="配置spring-mvc的messageconverter"></a>配置spring-mvc的messageconverter</h2><pre><code class="xml">    &lt;bean        class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;        &lt;property name=&quot;cacheSeconds&quot; value=&quot;0&quot; /&gt;        &lt;!--日期格式转换 --&gt;        &lt;property name=&quot;webBindingInitializer&quot;&gt;            &lt;bean class=&quot;com.kingray.spring.http.convert.DateConverter&quot; /&gt;        &lt;/property&gt;        &lt;property name=&quot;messageConverters&quot;&gt;            &lt;list&gt;                &lt;bean                    class=&quot;com.xiongyingqi.spring.http.convert.json.Jackson2HttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;com.xiongyingqi.spring.http.convert.json.JacksonHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.BufferedImageHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.ResourceHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean class=&quot;org.springframework.http.converter.FormHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.feed.AtomFeedHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.feed.RssChannelHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.xml.SourceHttpMessageConverter&quot;&gt;                &lt;/bean&gt;                &lt;bean                    class=&quot;org.springframework.http.converter.ByteArrayHttpMessageConverter&quot;&gt;                &lt;/bean&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;</code></pre><h2 id="重写spring的MappingJackson2HttpMessageConverter类-这样输出的json内容就能自定义"><a href="#重写spring的MappingJackson2HttpMessageConverter类-这样输出的json内容就能自定义" class="headerlink" title="重写spring的MappingJackson2HttpMessageConverter类,这样输出的json内容就能自定义"></a>重写spring的MappingJackson2HttpMessageConverter类,这样输出的json内容就能自定义</h2><pre><code class="java">package com.xiongyingqi.spring.http.convert.json;import java.io.IOException;import com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder;import org.springframework.http.HttpOutputMessage;import org.springframework.http.converter.HttpMessageNotWritableException;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import com.fasterxml.jackson.core.JsonEncoding;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;/** * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; * @version 2013-9-27 下午4:05:46 */public class Jackson2HttpMessageConverter extends MappingJackson2HttpMessageConverter {    private ObjectMapper objectMapper = new ObjectMapper();    private boolean prefixJson = false;    /**     * &lt;br&gt;     * 2013-9-27 下午4:10:28     *     * @see org.springframework.http.converter.json.MappingJacksonHttpMessageConverter#writeInternal(Object,     * org.springframework.http.HttpOutputMessage)     */    @Override    protected void writeInternal(Object object, HttpOutputMessage outputMessage)            throws IOException, HttpMessageNotWritableException {        // super.writeInternal(object, outputMessage);        // 判断是否需要重写objectMapper        ObjectMapper objectMapper = this.objectMapper;// 本地化ObjectMapper，防止方法级别的ObjectMapper改变全局ObjectMapper        if (ThreadJacksonMixInHolder.isContainsMixIn()) {            objectMapper = ThreadJacksonMixInHolder.builderMapper();        }        JsonEncoding encoding = getJsonEncoding(outputMessage.getHeaders().getContentType());        JsonGenerator jsonGenerator = objectMapper.getFactory().createGenerator(                outputMessage.getBody(), encoding);        // A workaround for JsonGenerators not applying serialization features        // https://github.com/FasterXML/jackson-databind/issues/12        if (objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT)) {            jsonGenerator.useDefaultPrettyPrinter();        }        try {            if (this.prefixJson) {                jsonGenerator.writeRaw(&quot;{} &amp;&amp; &quot;);            }            objectMapper.writeValue(jsonGenerator, object);        } catch (JsonProcessingException ex) {            throw new HttpMessageNotWritableException(&quot;Could not write JSON: &quot; + ex.getMessage(),                    ex);        }        // JsonEncoding encoding =        // getJsonEncoding(outputMessage.getHeaders().getContentType());        // JsonGenerator jsonGenerator =        // this.objectMapper.getJsonFactory().createJsonGenerator(outputMessage.getBody(),        // encoding);        //        // // A workaround for JsonGenerators not applying serialization        // features        // // https://github.com/FasterXML/jackson-databind/issues/12        // if (this.objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT))        // {        // jsonGenerator.useDefaultPrettyPrinter();        // }        //        // try {        // if (this.prefixJson) {        // jsonGenerator.writeRaw(&quot;{} &amp;&amp; &quot;);        // }        // this.objectMapper.writeValue(jsonGenerator, object);        // }        // catch (JsonProcessingException ex) {        // throw new HttpMessageNotWritableException(&quot;Could not write JSON: &quot; +        // ex.getMessage(), ex);        // }    }    public boolean isPrefixJson() {        return prefixJson;    }    public void setPrefixJson(boolean prefixJson) {        this.prefixJson = prefixJson;    }}</code></pre><h2 id="在方法上注解"><a href="#在方法上注解" class="headerlink" title="在方法上注解"></a>在方法上注解</h2><h3 id="Controller方法的示例，yxResourceSelfRelationsForSuperiorResourceId是YxResource内要过滤的属性"><a href="#Controller方法的示例，yxResourceSelfRelationsForSuperiorResourceId是YxResource内要过滤的属性" class="headerlink" title="Controller方法的示例，yxResourceSelfRelationsForSuperiorResourceId是YxResource内要过滤的属性:"></a>Controller方法的示例，yxResourceSelfRelationsForSuperiorResourceId是YxResource内要过滤的属性:</h3><pre><code class="java">    @IgnoreProperties(value= {           @IgnoreProperty(pojo = YxResource.class, name = {                  &quot;yxResourceSelfRelationsForSuperiorResourceId&quot;})})   @RequestMapping(value = &quot;/{resourceId}&quot;, method = RequestMethod.GET)   @ResponseBody   public Object getResourceByResourceId(@PathVariable Integer resourceId) {       YxResource resource = resourceService.getResource(resourceId);       return resource;    }</code></pre><h1 id="主要类说明"><a href="#主要类说明" class="headerlink" title="主要类说明"></a>主要类说明</h1><h2 id="自定义注解类：这些类是用于注解实体类输出json时要注解过滤的属性"><a href="#自定义注解类：这些类是用于注解实体类输出json时要注解过滤的属性" class="headerlink" title="自定义注解类：这些类是用于注解实体类输出json时要注解过滤的属性"></a>自定义注解类：这些类是用于注解实体类输出json时要注解过滤的属性</h2><h3 id="IgnoreProperties-java-用于同时注解IgnoreProperty和AllowProperty"><a href="#IgnoreProperties-java-用于同时注解IgnoreProperty和AllowProperty" class="headerlink" title="IgnoreProperties.java 用于同时注解IgnoreProperty和AllowProperty"></a><code>IgnoreProperties.java</code> 用于同时注解<code>IgnoreProperty</code>和<code>AllowProperty</code></h3><pre><code class="java">package com.xiongyingqi.jackson.annotation;import java.lang.annotation.*;/** * json属性过滤注解，对于同一个pojo来说 @AllowProperty 是与 @IgnoreProperty 是冲突的，如果这两个注解注解了&lt;br&gt; * 例如以下代码YxResource实体只会显示resourceName和resourceDescribe属性 * &lt;p/&gt; * &lt;pre&gt; * @IgnoreProperties( *     value = { *         @IgnoreProperty( *             pojo = YxResource.class, *             name = { *                 &quot;yxResourceDataRelations&quot;, *                 &quot;yxResourceSelfRelationsForSublevelResourceId&quot;, *                 &quot;yxPermisionResourceRelations&quot; }), *         @IgnoreProperty( *             pojo = YxResourceSelfRelation.class, *             name = { *                 &quot;yxResourceBySuperiorResourceId&quot;, *                 &quot;id&quot; }) *    }, *     allow = { *     @AllowProperty( *             pojo = YxResource.class, *             name = { &quot;&lt;b&gt;&lt;i&gt;resourceName&lt;/i&gt;&lt;/b&gt;&quot; }) }) *     @AllowProperty( *             pojo = YxResource.class, *             name = { &quot;&lt;b&gt;&lt;i&gt;resourceDescribe&lt;/i&gt;&lt;/b&gt;&quot; }) * &lt;/pre&gt; * &lt;p/&gt; * &lt;p/&gt; * 但是，对于同一个pojo的同一属性来说@AllowProperty是与@IgnoreProperty则会按照@IgnoreProperty过滤的属性名过滤 * 例如以下代码YxResource实体不会显示resourceName属性的值 * &lt;p/&gt; * &lt;pre&gt; * @IgnoreProperties( *     value = { *     @IgnoreProperty( *             pojo = YxResource.class, *             name = { &quot;&lt;b&gt;&lt;i&gt;resourceName&lt;/i&gt;&lt;/b&gt;&quot;, *                 &quot;yxResourceDataRelations&quot;, *                 &quot;yxResourceSelfRelationsForSublevelResourceId&quot;, *                 &quot;yxPermisionResourceRelations&quot; }), *     @IgnoreProperty( *             pojo = YxResourceSelfRelation.class, *             name = { *                 &quot;yxResourceBySuperiorResourceId&quot;, *                 &quot;id&quot; }) *    }, *     allow = { *     @AllowProperty( *             pojo = YxResource.class, *             name = { &quot;&lt;b&gt;&lt;i&gt;resourceName&lt;/i&gt;&lt;/b&gt;&quot; }) }) * &lt;/pre&gt; * * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; * @version 2013-9-27 下午4:18:39 */@Documented@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)public @interface IgnoreProperties {    /**     * 要过滤的属性     *     * @return     */    IgnoreProperty[] value() default @IgnoreProperty(pojo = Object.class, name = &quot;&quot;);    /**     * 允许的属性     *     * @return     */    AllowProperty[] allow() default @AllowProperty(pojo = Object.class, name = &quot;&quot;);}</code></pre><h3 id="IgnoreProperty-java：过滤指定对象内的指定字段名"><a href="#IgnoreProperty-java：过滤指定对象内的指定字段名" class="headerlink" title="IgnoreProperty.java：过滤指定对象内的指定字段名"></a><code>IgnoreProperty.java</code>：过滤指定对象内的指定字段名</h3><pre><code class="java">package com.xiongyingqi.jackson.annotation;import java.lang.annotation.*;/** * 用于注解json过滤pojo内的属性，其他的属性都会被序列化成字符串 * * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; * @version 2013-9-27 下午4:24:33 */@Documented@Target({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface IgnoreProperty {    /**     * 要忽略字段的POJO &lt;br&gt;     * 2013-9-27 下午4:27:08     *     * @return     */    Class&lt;?&gt; pojo();    /**     * 要忽略的字段名 &lt;br&gt;     * 2013-9-27 下午4:27:12     *     * @return     */    String[] name();    /**     * 字段名，无论是哪种 &lt;br&gt;     * 2013-9-27 下午4:27:15     *     * @return     */    //    String value() default &quot;&quot;;    /**     * 最大迭代层次&lt;br&gt;     * 当注解了pojo和name值时，该值表示遍历bean属性的最大曾次数，此注解一般用于自关联的bean类，     * 如果循环层次大于等于maxLevel时则不再读取属性&lt;br&gt;     * 如果maxIterationLevel为0，则不限制迭代层次&lt;br&gt;     * 如果maxIterationLevel为1，则迭代读取属性一次&lt;br&gt;     * 2013-10-21 下午2:16:26     *     * @return     */    //    int maxIterationLevel() default 0;}</code></pre><h3 id="AllowProperty-java：注解实体类允许的字段"><a href="#AllowProperty-java：注解实体类允许的字段" class="headerlink" title="AllowProperty.java：注解实体类允许的字段"></a><code>AllowProperty.java</code>：注解实体类允许的字段</h3><pre><code class="java">package com.xiongyingqi.jackson.annotation;import java.lang.annotation.*;/** * 只允许pojo内的属性序列化成json，对于同一个pojo该注解是与IgnoreProperty是冲突的&lt;br&gt; * * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; * @version 2013-10-30 下午3:57:35 */@Documented@Target({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface AllowProperty {    /**     * 目标POJO &lt;br&gt;     * 2013-9-27 下午4:27:08     *     * @return     */    Class&lt;?&gt; pojo();    /**     * 允许序列化的属性名 &lt;br&gt;     * 2013-9-27 下午4:27:12     *     * @return     */    String[] name();}</code></pre><h2 id="核心处理类，用于处理自定义注解并将生成的类存入当前线程"><a href="#核心处理类，用于处理自定义注解并将生成的类存入当前线程" class="headerlink" title="核心处理类，用于处理自定义注解并将生成的类存入当前线程"></a>核心处理类，用于处理自定义注解并将生成的类存入当前线程</h2><pre><code class="java">package com.xiongyingqi.jackson.impl;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.core.JsonEncoding;import com.fasterxml.jackson.databind.ObjectMapper;import com.xiongyingqi.jackson.FilterPropertyHandler;import com.xiongyingqi.jackson.annotation.AllowProperty;import com.xiongyingqi.jackson.annotation.IgnoreProperties;import com.xiongyingqi.jackson.annotation.IgnoreProperty;import com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder;import com.xiongyingqi.util.EntityHelper;import com.xiongyingqi.util.StringHelper;import javassist.CannotCompileException;import javassist.ClassPool;import javassist.CtClass;import javassist.bytecode.AnnotationsAttribute;import javassist.bytecode.ClassFile;import javassist.bytecode.ConstPool;import javassist.bytecode.annotation.*;import org.apache.log4j.Logger;import org.springframework.http.MediaType;import org.springframework.web.bind.annotation.ResponseBody;import java.lang.reflect.Method;import java.nio.charset.Charset;import java.util.*;import java.util.Map.Entry;//@IgnoreProperty(pojo = YxUserRoleRelation.class, name = { &quot;id&quot;, &quot;yxUser&quot; })/** * 使用代理来创建jackson的MixInAnnotation注解接口&lt;br&gt; * 如果使用本实现方法，一定要配置在web.xml中配置过滤器WebContextFilter，否则无法输出json到客户端 * * @author 瑛琪 &lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; * @version 2013-10-25 下午2:31:21 */public class JavassistFilterPropertyHandler implements FilterPropertyHandler {    public static final Logger LOGGER = Logger.getLogger(JavassistFilterPropertyHandler.class);    /**     * 注解的方法对应生成的代理类映射表     */    private static Map&lt;Method, Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; proxyMethodMap = new HashMap&lt;Method, Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt;();    /**     * String数组的hashCode与生成的对应的代理类的映射表     */    private static Map&lt;Integer, Class&lt;?&gt;&gt; proxyMixInAnnotationMap = new HashMap&lt;Integer, Class&lt;?&gt;&gt;();    private static String[] globalIgnoreProperties = new String[]{&quot;hibernateLazyInitializer&quot;,            &quot;handler&quot; };    /**     * 如果是标注的SpringMVC中的Controller方法，则应判断是否注解了@ResponseBody     */    private boolean isResponseBodyAnnotation;    /**     * 创建代理接口的唯一值索引     */    private static int proxyIndex;    public JavassistFilterPropertyHandler() {    }    public JavassistFilterPropertyHandler(String[] globalIgnoreProperties) {        JavassistFilterPropertyHandler.globalIgnoreProperties = globalIgnoreProperties;    }    /**     * @param isResponseBodyAnnotation 如果是标注的SpringMVC中的Controller方法，则应判断是否注解了@ResponseBody     */    public JavassistFilterPropertyHandler(boolean isResponseBodyAnnotation) {        this.isResponseBodyAnnotation = isResponseBodyAnnotation;    }    /**     * &lt;br&gt;     * 2013-10-28 上午11:11:24     *     * @param collection     * @param names     * @return     */    private Collection&lt;String&gt; checkAndPutToCollection(Collection&lt;String&gt; collection, String[] names) {        if (collection == null) {            collection = new HashSet&lt;String&gt;();        }        Collections.addAll(collection, names);        return collection;    }    private Collection&lt;String&gt; putGlobalIgnoreProperties(Collection&lt;String&gt; collection) {        if (globalIgnoreProperties != null) {            if (collection == null) {                collection = new HashSet&lt;String&gt;();            }            for (int i = 0; i &lt; globalIgnoreProperties.length; i++) {                String name = globalIgnoreProperties[i];                collection.add(name);            }        }        return collection;    }    /**     * 处理IgnoreProperties注解 &lt;br&gt;     * 2013-10-30 下午6:15:41     *     * @param properties     * @param pojoAndNamesMap     */    private void processIgnorePropertiesAnnotation(IgnoreProperties properties,                                                   Map&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; pojoAndNamesMap) {        IgnoreProperty[] values = properties.value();        AllowProperty[] allowProperties = properties.allow();        if (allowProperties != null) {            for (AllowProperty allowProperty : allowProperties) {                processAllowPropertyAnnotation(allowProperty, pojoAndNamesMap);            }        }        if (values != null) {            for (IgnoreProperty property : values) {                processIgnorePropertyAnnotation(property, pojoAndNamesMap);            }        }    }    /**     * 处理IgnoreProperty注解 &lt;br&gt;     * 2013-10-30 下午6:16:08     *     * @param property     * @param pojoAndNamesMap     */    private void processIgnorePropertyAnnotation(IgnoreProperty property,                                                 Map&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; pojoAndNamesMap) {        String[] names = property.name();        Class&lt;?&gt; pojoClass = property.pojo();        // Class&lt;?&gt; proxyAnnotationInterface = createMixInAnnotation(names);//        // 根据注解创建代理接口        Collection&lt;String&gt; nameCollection = pojoAndNamesMap.get(pojoClass);        nameCollection = checkAndPutToCollection(nameCollection, names);        pojoAndNamesMap.put(pojoClass, nameCollection);    }    /**     * 处理AllowProperty注解 &lt;br&gt;     * 2013-10-30 下午6:16:08     *     * @param property     * @param pojoAndNamesMap     */    private void processAllowPropertyAnnotation(AllowProperty property,                                                Map&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; pojoAndNamesMap) {        String[] allowNames = property.name();        Class&lt;?&gt; pojoClass = property.pojo();        Collection&lt;String&gt; ignoreProperties = EntityHelper                .getUnstaticClassFieldNameCollection(pojoClass);        Collection&lt;String&gt; allowNameCollection = new ArrayList&lt;String&gt;();        Collections.addAll(allowNameCollection, allowNames);        Collection&lt;String&gt; nameCollection = pojoAndNamesMap.get(pojoClass);        if (nameCollection != null) {            nameCollection.removeAll(allowNameCollection);        } else {            ignoreProperties.removeAll(allowNameCollection);            nameCollection = ignoreProperties;        }        pojoAndNamesMap.put(pojoClass, nameCollection);    }    /**     * 根据方法获取过滤映射表 &lt;br&gt;     * 2013-10-25 下午2:47:34     *     * @param method 注解了 @IgnoreProperties 或 @IgnoreProperty 的方法（所在的类）     * @return Map&lt;Class&lt;?&gt;, Collection&lt;Class&lt;?&gt;&gt;&gt; pojo与其属性的映射表     */    public Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; getProxyMixInAnnotation(Method method) {        if (isResponseBodyAnnotation &amp;&amp; !method.isAnnotationPresent(ResponseBody.class)) {            return null;        }        Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map = proxyMethodMap.get(method);// 从缓存中查找是否存在        if (map != null &amp;&amp; map.entrySet().size() &gt; 0) {// 如果已经读取该方法的注解信息，则从缓存中读取            return map;        } else {            map = new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;();        }        Class&lt;?&gt; clazzOfMethodIn = method.getDeclaringClass();// 方法所在的class        Map&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; pojoAndNamesMap = new HashMap&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt;();        IgnoreProperties classIgnoreProperties = clazzOfMethodIn                .getAnnotation(IgnoreProperties.class);        IgnoreProperty classIgnoreProperty = clazzOfMethodIn.getAnnotation(IgnoreProperty.class);        AllowProperty classAllowProperty = clazzOfMethodIn.getAnnotation(AllowProperty.class);        IgnoreProperties ignoreProperties = method.getAnnotation(IgnoreProperties.class);        IgnoreProperty ignoreProperty = method.getAnnotation(IgnoreProperty.class);        AllowProperty allowProperty = method.getAnnotation(AllowProperty.class);        if (allowProperty != null) {// 方法上的AllowProperty注解            processAllowPropertyAnnotation(allowProperty, pojoAndNamesMap);        }        if (classAllowProperty != null) {            processAllowPropertyAnnotation(classAllowProperty, pojoAndNamesMap);        }        if (classIgnoreProperties != null) {// 类上的IgnoreProperties注解            processIgnorePropertiesAnnotation(classIgnoreProperties, pojoAndNamesMap);        }        if (classIgnoreProperty != null) {// 类上的IgnoreProperty注解            processIgnorePropertyAnnotation(classIgnoreProperty, pojoAndNamesMap);        }        if (ignoreProperties != null) {// 方法上的IgnoreProperties注解            processIgnorePropertiesAnnotation(ignoreProperties, pojoAndNamesMap);        }        if (ignoreProperty != null) {// 方法上的IgnoreProperties注解            processIgnorePropertyAnnotation(ignoreProperty, pojoAndNamesMap);        }        Set&lt;Entry&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt;&gt; entries = pojoAndNamesMap.entrySet();        for (Iterator&lt;Entry&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt;&gt; iterator = entries.iterator(); iterator                .hasNext(); ) {            Entry&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt; entry = (Entry&lt;Class&lt;?&gt;, Collection&lt;String&gt;&gt;) iterator                    .next();            Collection&lt;String&gt; nameCollection = entry.getValue();            nameCollection = putGlobalIgnoreProperties(nameCollection);// 将全局过滤字段放入集合内            String[] names = nameCollection.toArray(new String[]{});            // EntityHelper.print(entry.getKey());            // for (int i = 0; i &lt; names.length; i++) {            // String name = names[i];            // EntityHelper.print(name);            // }            Class&lt;?&gt; clazz = createMixInAnnotation(names);            map.put(entry.getKey(), clazz);        }        proxyMethodMap.put(method, map);        return map;    }    /**     * 创建jackson的代理注解接口类 &lt;br&gt;     * 2013-10-25 上午11:59:50     *     * @param names 要生成的字段     * @return 代理接口类     */    private Class&lt;?&gt; createMixInAnnotation(String[] names) {        Class&lt;?&gt; clazz = null;        clazz = proxyMixInAnnotationMap.get(StringHelper.hashCodeOfStringArray(names));        if (clazz != null) {            return clazz;        }        ClassPool pool = ClassPool.getDefault();        // 创建代理接口        CtClass cc = pool.makeInterface(&quot;ProxyMixInAnnotation&quot; + System.currentTimeMillis()                + proxyIndex++);        ClassFile ccFile = cc.getClassFile();        ConstPool constpool = ccFile.getConstPool();        // create the annotation        AnnotationsAttribute attr = new AnnotationsAttribute(constpool,                AnnotationsAttribute.visibleTag);        // 创建JsonIgnoreProperties注解        Annotation jsonIgnorePropertiesAnnotation = new Annotation(                JsonIgnoreProperties.class.getName(), constpool);        BooleanMemberValue ignoreUnknownMemberValue = new BooleanMemberValue(false, constpool);        ArrayMemberValue arrayMemberValue = new ArrayMemberValue(constpool);// value的数组成员        Collection&lt;MemberValue&gt; memberValues = new HashSet&lt;MemberValue&gt;();        for (int i = 0; i &lt; names.length; i++) {            String name = names[i];            StringMemberValue memberValue = new StringMemberValue(constpool);// 将name值设入注解内            memberValue.setValue(name);            memberValues.add(memberValue);        }        arrayMemberValue.setValue(memberValues.toArray(new MemberValue[]{}));        jsonIgnorePropertiesAnnotation.addMemberValue(&quot;value&quot;, arrayMemberValue);        jsonIgnorePropertiesAnnotation.addMemberValue(&quot;ignoreUnknown&quot;, ignoreUnknownMemberValue);        attr.addAnnotation(jsonIgnorePropertiesAnnotation);        ccFile.addAttribute(attr);        // generate the class        try {            clazz = cc.toClass();            proxyMixInAnnotationMap.put(StringHelper.hashCodeOfStringArray(names), clazz);            // JsonIgnoreProperties ignoreProperties = (JsonIgnoreProperties)            // clazz            // .getAnnotation(JsonIgnoreProperties.class);            // EntityHelper.print(ignoreProperties);            //            // EntityHelper.print(clazz);            // try {            // Object instance = clazz.newInstance();            // EntityHelper.print(instance);            //            // } catch (InstantiationException e) {            // e.printStackTrace();            // } catch (IllegalAccessException e) {            // e.printStackTrace();            // }        } catch (CannotCompileException e) {            e.printStackTrace();        }        // right        // mthd.getMethodInfo().addAttribute(attr);        return clazz;    }    @Override    public Object filterProperties(Method method, Object object) {        Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map = getProxyMixInAnnotation(method);        if (map == null || map.entrySet().size() == 0) {// 如果该方法上没有注解，则返回原始对象            return object;        }//        Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; entries = map.entrySet();//        for (Iterator&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; iterator = entries.iterator(); iterator.hasNext();) {//            Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; entry = (Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;) iterator.next();//            //            EntityHelper.print(entry.getKey());//            Class&lt;?&gt; clazz = entry.getValue();//            //            EntityHelper.print(clazz.getAnnotation(JsonIgnoreProperties.class));//        }//        ObjectMapper mapper = createObjectMapper(map);        ThreadJacksonMixInHolder.addMixIns(getEntries(map));//        try {//            HttpServletResponse response = WebContext.getInstance().getResponse();//            writeJson(mapper, response, object);//        } catch (WebContextAlreadyClearedException e) {//            e.printStackTrace();//        }        return object;    }    public Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; getEntries(Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map) {        Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; entries = map.entrySet();        return entries;    }    /**     * 根据指定的过滤表创建jackson对象 &lt;br&gt;     * 2013-10-25 下午2:46:43     *     * @param map 过滤表     * @return ObjectMapper     */    private ObjectMapper createObjectMapper(Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map) {        ObjectMapper mapper = new ObjectMapper();        Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; entries = map.entrySet();        for (Iterator&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; iterator = entries.iterator(); iterator.hasNext(); ) {            Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; entry = iterator.next();            mapper.addMixInAnnotations(entry.getKey(), entry.getValue());        }        return mapper;    }    /**     * 根据方法上的注解生成objectMapper     *     * @param method     * @return     */    public ObjectMapper createObjectMapper(Method method) {        return createObjectMapper(getProxyMixInAnnotation(method));    }//    /**//     * 将结果输出到response &lt;br&gt;//     * 2013-10-25 下午2:28:40//     *//     * @param objectMapper//     * @param response//     * @param object//     *///    private void writeJson(ObjectMapper objectMapper, HttpServletResponse response, Object object) {//        response.setContentType(&quot;application/json&quot;);////        JsonEncoding encoding = getJsonEncoding(response.getCharacterEncoding());//        JsonGenerator jsonGenerator = null;//        try {//            jsonGenerator = objectMapper.getJsonFactory().createJsonGenerator(//                    response.getOutputStream(), encoding);//        } catch (IOException e1) {//            e1.printStackTrace();//        }////        // A workaround for JsonGenerators not applying serialization features//        // https://github.com/FasterXML/jackson-databind/issues/12//        if (objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT)) {//            jsonGenerator.useDefaultPrettyPrinter();//        }////        try {//            objectMapper.writeValue(jsonGenerator, object);//        } catch (JsonProcessingException ex) {//            LOGGER.error(ex);////            throw new HttpMessageNotWritableException(&quot;Could not write JSON: &quot; + ex.getMessage(),//                    ex);//        } catch (IOException e) {//            LOGGER.error(e);//            // e.printStackTrace();//        }////    }    /**     * &lt;br&gt;     * 2013-10-25 下午12:29:58     *     * @param characterEncoding     * @return     */    private JsonEncoding getJsonEncoding(String characterEncoding) {        for (JsonEncoding encoding : JsonEncoding.values()) {            if (characterEncoding.equals(encoding.getJavaName())) {                return encoding;            }        }        return JsonEncoding.UTF8;    }    /**     * Determine the JSON encoding to use for the given content type.     *     * @param contentType the media type as requested by the caller     * @return the JSON encoding to use (never {@code null})     */    protected JsonEncoding getJsonEncoding(MediaType contentType) {        if (contentType != null &amp;&amp; contentType.getCharSet() != null) {            Charset charset = contentType.getCharSet();            for (JsonEncoding encoding : JsonEncoding.values()) {                if (charset.name().equals(encoding.getJavaName())) {                    return encoding;                }            }        }        return JsonEncoding.UTF8;    }}</code></pre><h2 id="线程持有类，用于在当前线程内保存核心类处理过的自定义注解生成的MixIn注解，并且能提供ObjectMapper的生成"><a href="#线程持有类，用于在当前线程内保存核心类处理过的自定义注解生成的MixIn注解，并且能提供ObjectMapper的生成" class="headerlink" title="线程持有类，用于在当前线程内保存核心类处理过的自定义注解生成的MixIn注解，并且能提供ObjectMapper的生成"></a>线程持有类，用于在当前线程内保存核心类处理过的自定义注解生成的MixIn注解，并且能提供ObjectMapper的生成</h2><pre><code class="java">package com.xiongyingqi.jackson.helper;import com.fasterxml.jackson.databind.ObjectMapper;import java.util.HashSet;import java.util.Map;import java.util.Set;/** * 在当前线程内保存ObjectMapper供Jackson2HttpMessageConverter使用 * Created by 瑛琪&lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; on 2014/4/1 0001. */public class ThreadJacksonMixInHolder {    private static ThreadLocal&lt;ThreadJacksonMixInHolder&gt; holderThreadLocal = new ThreadLocal&lt;ThreadJacksonMixInHolder&gt;();    private Set&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; mixIns;    private ObjectMapper mapper;    private org.codehaus.jackson.map.ObjectMapper codehausMapper;    /**     * 根据当前MixIn集合生成objectMapper&lt;p&gt;     * &lt;p/&gt;     * &lt;b&gt;注意：该方法在返回mapper对象之后调用clear方法，如果再次调用builderMapper()肯定会保存&lt;/b&gt;     *     * @return     */    public static ObjectMapper builderMapper() {        ThreadJacksonMixInHolder holder = holderThreadLocal.get();        if (holder.mapper == null &amp;&amp; isContainsMixIn()) {            holder.mapper = new ObjectMapper();            for (Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; mixIn : holder.mixIns) {                holder.mapper.addMixInAnnotations(mixIn.getKey(), mixIn.getValue());            }        }        clear();// 如果不调用clear可能导致线程内的数据是脏的！        return holder.mapper;    }    /**     * 根据当前MixIn集合生成objectMapper     *     * @return     */    public static org.codehaus.jackson.map.ObjectMapper builderCodehausMapper() {        ThreadJacksonMixInHolder holder = holderThreadLocal.get();        if (holder.codehausMapper == null &amp;&amp; isContainsMixIn()) {            holder.codehausMapper = new org.codehaus.jackson.map.ObjectMapper();            for (Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; mixIn : holder.mixIns) {                holder.codehausMapper.getDeserializationConfig().addMixInAnnotations(mixIn.getKey(), mixIn.getValue());                holder.codehausMapper.getSerializationConfig().addMixInAnnotations(mixIn.getKey(), mixIn.getValue());            }        }        clear();// 如果不调用clear可能导致线程内的数据是脏的！        return holder.codehausMapper;    }    /**     * 清除当前线程内的数据     */    public static void clear() {        holderThreadLocal.set(null);//        holderThreadLocal.remove();    }    /**     * 设置MixIn集合到线程内，如果线程内已经存在数据，则会先清除     *     * @param resetMixIns     */    public static void setMixIns(Set&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; resetMixIns) {        ThreadJacksonMixInHolder holder = holderThreadLocal.get();        if (holder == null) {            holder = new ThreadJacksonMixInHolder();            holderThreadLocal.set(holder);        }        holder.mixIns = resetMixIns;    }    /**     * 不同于setMixIns，addMixIns为增加MixIn集合到线程内，即不会清除已经保存的数据     * &lt;br&gt;2014年4月4日 下午12:08:15     *     * @param toAddMixIns     */    public static void addMixIns(Set&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; toAddMixIns) {        ThreadJacksonMixInHolder holder = holderThreadLocal.get();        if (holder == null) {            holder = new ThreadJacksonMixInHolder();            holderThreadLocal.set(holder);        }        if (holder.mixIns == null) {            holder.mixIns = new HashSet&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt;();        }        holder.mixIns.addAll(toAddMixIns);    }    /**     * 获取线程内的MixIn集合&lt;p&gt;&lt;/p&gt;     * &lt;b&gt;注意：为了防止线程执行完毕之后仍然存在有数据，请务必适时调用clear()方法&lt;/b&gt;     *     * @return     * @see com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder#builderMapper()     * @see com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder#builderCodehausMapper()     * @see com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder#clear()     */    public static Set&lt;Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; getMixIns() {        ThreadJacksonMixInHolder holder = holderThreadLocal.get();        return holder.mixIns;    }    /**     * 判断当前线程是否存在MixIn集合     *     * @return     */    public static boolean isContainsMixIn() {        if (holderThreadLocal.get() == null) {            return false;        }        if (holderThreadLocal.get().mixIns != null &amp;&amp; holderThreadLocal.get().mixIns.size() &gt; 0) {            return true;        }        return false;    }}</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><pre><code class="java">package com.xiongyingqi.jackson;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.xiongyingqi.jackson.annotation.IgnoreProperties;import com.xiongyingqi.jackson.annotation.IgnoreProperty;import com.xiongyingqi.jackson.helper.ThreadJacksonMixInHolder;import com.xiongyingqi.jackson.impl.JavassistFilterPropertyHandler;import com.xiongyingqi.jackson.pojo.Group;import com.xiongyingqi.jackson.pojo.User;import com.xiongyingqi.util.Assert;import com.xiongyingqi.util.EntityHelper;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;/** * Created by 瑛琪&lt;a href=&quot;http://xiongyingqi.com&quot;&gt;xiongyingqi.com&lt;/a&gt; on 2014/6/4 0004. */public class JsonFilterPropertyTest {    @IgnoreProperties(@IgnoreProperty(pojo = User.class, name = &quot;id&quot;))    public Collection&lt;User&gt; listUsers() {        Group group1 = new Group();        group1.setId(1);        group1.setName(&quot;分组1&quot;);        User user1 = new User();        user1.setId(1);        user1.setGroup(group1);        user1.setName(&quot;用户1&quot;);        User user2 = new User();        user2.setId(1);        user2.setGroup(group1);        user2.setName(&quot;用户1&quot;);        User user3 = new User();        user3.setId(1);        user3.setName(&quot;用户1&quot;);        user3.setGroup(group1);        Group group2 = new Group();        group2.setId(2);        group2.setName(&quot;分组2&quot;);        User user4 = new User();        user4.setId(4);        user4.setGroup(group2);        user4.setName(&quot;用户4&quot;);        User user5 = new User();        user5.setId(5);        user5.setGroup(group2);        user5.setName(&quot;用户5&quot;);        User user6 = new User();        user6.setId(6);        user6.setName(&quot;用户6&quot;);        user6.setGroup(group2);        Collection&lt;User&gt; users = new ArrayList&lt;User&gt;();        users.add(user1);        users.add(user2);        users.add(user3);        users.add(user4);        users.add(user5);        users.add(user6);        return users;    }    @Test    public void jsonTest() throws NoSuchMethodException, JsonProcessingException {        FilterPropertyHandler filterPropertyHandler = new JavassistFilterPropertyHandler(false);        Object object = listUsers();        object = filterPropertyHandler.filterProperties(JsonFilterPropertyTest.class.getMethod(&quot;listUsers&quot;), object);        ObjectMapper mapper = ThreadJacksonMixInHolder.builderMapper();        String json = mapper.writeValueAsString(object);        EntityHelper.print(json);        Assert.hasText(json);    }}</code></pre><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><hr><pre><code>at com.xiongyingqi.jackson.JsonFilterPropertyTest.jsonTest(JsonFilterPropertyTest.java:80)String =============== [{&quot;name&quot;:&quot;用户1&quot;,&quot;group&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;分组1&quot;}},{&quot;name&quot;:&quot;用户1&quot;,&quot;group&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;分组1&quot;}},{&quot;name&quot;:&quot;用户1&quot;,&quot;group&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;分组1&quot;}},{&quot;name&quot;:&quot;用户4&quot;,&quot;group&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;分组2&quot;}},{&quot;name&quot;:&quot;用户5&quot;,&quot;group&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;分组2&quot;}},{&quot;name&quot;:&quot;用户6&quot;,&quot;group&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;分组2&quot;}}]</code></pre><hr><h1 id="性能与缺陷"><a href="#性能与缺陷" class="headerlink" title="性能与缺陷"></a>性能与缺陷</h1><ul><li>主要是在map内存储了Javassist的临时类，每个注解(IgnoreProperties等)的方法的调用，对应在FilterPropertyHandler会处理一次注解并在内存内产生一个Javassist临时类，但是访问过一次之后该类就会读取map缓存</li><li>ThreadJacksonMixInHolder：这个类的原理就是使用ThreadLocal在当前线程内存储处理过的annotation注解，java的容器或框架都是使用了该类，导致的效率问题应该不大</li><li>未知的bug</li></ul><h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><p>其他框架内使用<br>如果不是spring-mvc框架也能使用这些代码来解决，只是必须要修改aop的捕获方法、使用new JavassistFilterPropertyHandler(false)禁用ResponseBody，以及在ObjectMapper输出使用自己定义的输出</p><h2 id="源代码地址"><a href="#源代码地址" class="headerlink" title="源代码地址"></a>源代码地址</h2><div class="github-widget" data-repo="blademainer/common_utils"></div><h2 id="代码已上传到maven中央库："><a href="#代码已上传到maven中央库：" class="headerlink" title="代码已上传到maven中央库："></a>代码已上传到maven中央库：</h2><p><a href="http://mvnrepository.com/artifact/com.xiongyingqi/common_helper" target="_blank" rel="external">http://mvnrepository.com/artifact/com.xiongyingqi/common_helper</a></p><h2 id="Maven-Usage"><a href="#Maven-Usage" class="headerlink" title="Maven Usage:"></a>Maven Usage:</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.xiongyingqi&lt;/groupId&gt;    &lt;artifactId&gt;common_helper&lt;/artifactId&gt;    &lt;version&gt;${common_utils.version}&lt;/version&gt;&lt;/dependency&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      springmvc中，默认使用jackson类返回java bean对象，但是如果存在回路时，会导致jackson输出循环。本文介绍如何通过自定义注解来定义过滤属性，web运行时如何通过AOP捕获Controller的ResponseBody注解的方法然后处理要过滤的属性。
    
    </summary>
    
      <category term="java" scheme="http://xiongyingqi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="javassist" scheme="http://xiongyingqi.com/tags/javassist/"/>
    
      <category term="spring-mvc" scheme="http://xiongyingqi.com/tags/spring-mvc/"/>
    
      <category term="jackson" scheme="http://xiongyingqi.com/tags/jackson/"/>
    
      <category term="循环" scheme="http://xiongyingqi.com/tags/%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="springmvc" scheme="http://xiongyingqi.com/tags/springmvc/"/>
    
      <category term="spring" scheme="http://xiongyingqi.com/tags/spring/"/>
    
      <category term="json" scheme="http://xiongyingqi.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Samba文件共享服务器</title>
    <link href="http://xiongyingqi.com/2014/01/06/2014-01-06-samba-linux-attentions/"/>
    <id>http://xiongyingqi.com/2014/01/06/2014-01-06-samba-linux-attentions/</id>
    <published>2014-01-06T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>#Linux安装Samba文件共享服务器<br>Samba相对于Windows服务器来说具有更灵活的配置、高效等特点。个人认为是共享服务器的最佳选择。</p><a id="more"></a><h1 id="安装samba："><a href="#安装samba：" class="headerlink" title="安装samba："></a>安装samba：</h1><pre><code class="bash">yum install samba</code></pre><p>ubuntu下yum对应命令为：</p><pre><code class="bash">apt-get install samba</code></pre><h1 id="samba主要配置文件在-etc-samba-smb-conf中"><a href="#samba主要配置文件在-etc-samba-smb-conf中" class="headerlink" title="samba主要配置文件在/etc/samba/smb.conf中"></a>samba主要配置文件在/etc/samba/smb.conf中</h1><pre><code class="bash">[global]        realm = 192.168.0.2        netbios name = SAMBA-SERVER        netbios aliases = SAMBA-SERVER        server string = Samba-Server        security = SHARE        log file = /var/log/samba/%m.log        max log size = 50        os level = 0        wins proxy = Yes        wins support = Yes        idmap config * : backend = tdb        hosts allow = 127., 192.        cups options = raw[test]        comment = test        path = /home/share/test        read only = No        create mask = 0777        directory mask = 0777</code></pre><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>其中比较要注意的是global中的security和hosts allow两个选项：</p><ul><li>security代表验证权限的机制，我一般使用share和user级别，这两种方式其实没多大区别~无非是先登录再查看还是先查看再登录的区别而已（注意：Linux的目录）</li><li>如果服务器共享了哪些文件夹是不怕公布并且多个部门使用同一个服务器以及各部门需要相互查看的话，建议使用share的方式，这样会极大的方便公司同事在windows中切换帐号。</li><li>hosts allow代表了哪些前缀的ip地址能访问服务器。</li></ul>]]></content>
    
    <summary type="html">
    
      Samba相对于Windows服务器来说具有更灵活的配置、高效等特点。个人认为是共享服务器的最佳选择。
    
    </summary>
    
      <category term="linux" scheme="http://xiongyingqi.com/categories/linux/"/>
    
    
      <category term="Samba" scheme="http://xiongyingqi.com/tags/Samba/"/>
    
      <category term="linux" scheme="http://xiongyingqi.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux使用shell脚本定时备份文件（夹）并删除一定日期之前的备份和日志</title>
    <link href="http://xiongyingqi.com/2014/01/04/2014-01-04-linux-backup-shell/"/>
    <id>http://xiongyingqi.com/2014/01/04/2014-01-04-linux-backup-shell/</id>
    <published>2014-01-04T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="备份的原理"><a href="#备份的原理" class="headerlink" title="备份的原理"></a>备份的原理</h1><p>使用Linux的Cron程序定时执行该脚本从而达到备份和删除备份历史的目的。</p><h1 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h1><p>脚本主要需要设置参数有三个：</p><ul><li>ORIGIN_FOLDER：要备份的目录，必须以\结尾</li><li>DES_FOLDER：备份文件存储路径（可以是网络路径，前提是必须要有权限管理该路径下的文件夹）</li><li>DAYS_AGO：该参数表示要删除多少天之前的备份（比如今天是2012年12月31日，那么20121221的文件不会被删除，20121220或比之小的文件夹将会被删除）<a id="more"></a></li></ul><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>BackUpTask.shell</p><pre><code class="bash">#!/bin/sh#---------------------------------------------------------------------#    shell自动备份文件夹同时检查一定日期前的文件夹并删除#    部署好本脚本后应当在linux中设置cron自动执行：#    1、在linux的/etc/cron.d/目录下新建空文件#    2、使用&quot;crontab -e&quot;编辑新的定时任务并保存#    3、chkconfig crond on#    （注意：在cron模式下文件操作必须使用绝对路径）#                                                        --by: Blademainer#---------------------------------------------------------------------#设置要备份的目录，多个文件夹以逗号分隔ORIGIN_FOLDER=test,testlog#设置备份文件的存储目录，可以是绝对路径DES_FOLDER=bak#设置删除多少天之前的备份DAYS_AGO=10#定义日期变量，时间戳的单位以秒为单位SECOND=1MINUTE=$((60*$SECOND))HOUR=$((60*$MINUTE))DAY=$((24*$HOUR))WEEK=$((7*$DAY))#time1=$(($(date +%s -d &#39;2010-01-01&#39;) - $(date +%s -d &#39;2009-01-01&#39;)));# 计算时间戳，以秒为单位#time2=$(($(date +%s -d &#39;2013-12-30 11:57:39&#39;)));# 计算时间戳，以秒为单位#time3=$(($(date +%s -d &quot;$(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&quot;)));# 计算时间戳，以秒为单位#echo $time3#echo $time2#echo $(($time1/$DAY))#当前日期的字符串表达形式NOW=$(date +&#39;%Y-%m-%d_%H%M%S&#39;)#echo $NOW#TEN_DAYS_AGO=$(($(date -d &#39;-10 day&#39; &quot;+%Y%m%d%H%M%S&quot;)))#echo 十天之前$TEN_DAYS_AGO#计算当前时间的时间戳表达方法TIME_NOW=$(($(date +%s -d &quot;$(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&quot;)))SECONDS_OF_DAYS_AGO=$(($DAYS_AGO * $DAY))#计算指定天数前的时间戳表达方法TIME_AGO=$(($TIME_NOW - $SECONDS_OF_DAYS_AGO))#echo $TIME_NOW#echo TIME_AGO============$TIME_AGO#判断传入的日期是否在设置的日期之前function isDaysBefore(){    DATE=$(($(date +%s -d $1)))    if [[ $DATE &lt; $TIME_AGO ]]     then        echo 1    else        echo 0    fi}#检验文件夹if [ ! -d &quot;$DES_FOLDER&quot; ]; then      echo `mkdir $DES_FOLDER`fiDES_PATH=$DES_FOLDER/$NOW/if [ ! -d &quot;$DES_PATH&quot; ]; then      echo `mkdir $DES_PATH`fiif [ ! -f &quot;$DES_FOLDER/$NOW/$NOW.log&quot; ]; then      echo `touch $DES_FOLDER/$NOW/$NOW.log`fi#拷贝文件夹var=`echo &quot;$ORIGIN_FOLDER&quot;|awk -F &#39;,&#39; &#39;{print $0}&#39; | sed &quot;s/,/ /g&quot;`for VAR_ORIGIN_FOLDER in $var; do    command=`cp -rf $VAR_ORIGIN_FOLDER $DES_PATH`done#删除备份文件夹for FOLDER in `ls $DES_FOLDER`; do    #截取年月日    folder_date=`expr substr $FOLDER 1 10`    if [[ $(isDaysBefore $folder_date) == 1 ]]    then        echo `rm -fr $DES_FOLDER/$FOLDER`    fidone</code></pre>]]></content>
    
    <summary type="html">
    
      通过Linux的shell功能实现对文件夹的拷贝，并根据文件夹的日期计算是否要删除该文件夹
    
    </summary>
    
      <category term="Linux" scheme="http://xiongyingqi.com/categories/Linux/"/>
    
    
      <category term="shell" scheme="http://xiongyingqi.com/tags/shell/"/>
    
      <category term="Linux" scheme="http://xiongyingqi.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Windows使用bat脚本定时备份文件（夹）并删除一定日期之前的备份和日志</title>
    <link href="http://xiongyingqi.com/2014/01/04/2014-01-04-windows-backup-bat/"/>
    <id>http://xiongyingqi.com/2014/01/04/2014-01-04-windows-backup-bat/</id>
    <published>2014-01-04T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="备份的原理"><a href="#备份的原理" class="headerlink" title="备份的原理"></a>备份的原理</h1><p>使用windows的任务计划程序定时执行该脚本从而达到备份和删除备份历史的目的。</p><h1 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h1><p>脚本主要需要设置参数有四个：</p><ul><li>bakPath：要备份的目录，必须以\结尾</li><li>bakTargetPath：备份文件存储路径（可以是网络路径，前提是必须要有权限管理该路径下的文件夹）</li><li>DaysAgo：该参数表示要删除多少天之前的备份（比如今天是2012年12月31日，那么20121221的文件不会被删除，20121220或比之小的文件夹将会被删除）</li><li>logDaysAgo：该参数表示要删除多少天之前的日志文件</li></ul><a id="more"></a><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>BackUpTask.bat</p><pre><code class="bash">::  ------------------------------------------------------------------------ ::                       自动备份及清除文件夹脚本说明::  本脚本能备份指定文件夹下的所有文件夹并以日期的形式来存放每次备份的文件夹，::  同时，能删除指定时间之前的备份文件夹。如果要使本脚本能按一定间隔时间来执行::  此脚本，那么请在系统定时任务内创建一个任务，并设置好执行时间，然后指定执行::  此脚本即可。::  注意：由于定时任务执行的方式与直接点击执行脚本的方式有很大差别（对于定时任::  务来说，脚本的相对路径其实就是相对于cmd.exe来说的路径），所以必须使用绝对::  路径的方式来进行拷贝。::  具体设置的参数：（所有的目录路径必须以\结尾）::  bakPath 要备份的目录，必须以\结尾::  bakTargetPath 备份文件存储路径（可以是网络路径，前提是必须要有权限管理该路径下的文件夹）::  DaysAgo 该参数表示要删除多少天之前的备份（比如今天是2012年12月31日，那么20121221的文件不会被删除，20121220或比之小的文件夹将会被删除）::  logDaysAgo 该参数表示要删除多少天之前的日志文件::                                                         --by Blademainer::  ------------------------------------------------------------------------ @echo off:: for /f &quot;tokens=1-3 delims=- &quot; %%1 in (&quot;%date%&quot;) do set ttt=%%1%%2%%3:: for /f &quot;tokens=1-3 delims=.: &quot; %%1 in (&quot;%time%&quot;) do set ttt=%ttt%-%%1%%2%%3:: 要备份的目录，必须以\结尾set bakPath=C:\Users\blademainer\Desktop\test\:: 备份文件存储路径（可以是网络路径，前提是必须要有权限管理该路径下的文件夹）set bakTargetPath=C:\Users\blademainer\Desktop\bak\:: 该参数表示要删除多少天之前的备份（比如今天是2012年12月31日，那么20121221的文件不会被删除，20121220或比之小的文件夹将会被删除）set DaysAgo=10:: 该参数表示要删除多少天之前的日志文件set logDaysAgo=%DaysAgo%:: ----------------------------------- 注意：除非你有足够的自信，否则不要变动以下参数 ----------------------------------- :: 日志存放路径set logDir=%bakTargetPath%\log\:: 截取日期函数set dateStr=%date:~0,4%%date:~5,2%%date:~8,2%:: 时间戳set timeStr=%time:~0,2%%time:~3,2%%time:~6,2%%time:~9,2%:: 得出的索引set indexStr=%dateStr%_%timeStr%:: 设置时间格式for /f &quot;tokens=1-3 delims=- &quot; %%1 in (&quot;%time%&quot;) do set beautyTime=%%1%%2%%3:: 日志文件名set logFile=%logDir%%indexStr%.log:: 获取最后一个文件夹名称call :LastFolder %bakPath% bakName:: 备份所在文件夹（按日期分）set bakDataFolder=%bakTargetPath%%indexStr%\:: 备份后的路径set bakDataPath=%bakDataFolder%%bakName%\echo bakDataPath======%bakDataPath%:: 创建日志目录if not exist %logDir% mkdir %logDir%echo 开始备份文件夹echo ------------------ %date% %beautyTime% ------------------  &gt;&gt; %logFile%if not exist %bakDataPath% mkdir %bakDataPath%xcopy %bakPath%* %bakDataPath% /c/s/e/y/r &gt;&gt; %logFile%IF ERRORLEVEL 1 ECHO ------------------ 文件拷贝失败 ------------------  &gt;&gt; %logFile%IF ERRORLEVEL 0 ECHO ------------------ 文件拷贝成功 ------------------  &gt;&gt; %logFile%::  ------------------- 计算指定DaysAgo天之前的日期 ------------------- :: 日期的格式为yyyymmddcall :DateToDays %date:~0,4% %date:~5,2% %date:~8,2% PassDaysset /a PassDays-=%DaysAgo%call :DaysToDate %PassDays% DstYear DstMonth DstDayset DstDate=%DstYear%%DstMonth%%DstDay%echo %DaysAgo%天前的日期是%DstDate%::  ------------------- 计算指定logDaysAgo天之前的日期 ------------------- :: 日期的格式为yyyymmddcall :DateToDays %date:~0,4% %date:~5,2% %date:~8,2% logPassDaysset /a logPassDays-=%logDaysAgo%call :DaysToDate %logPassDays% DstYear DstMonth DstDayset logDstDate=%DstYear%%DstMonth%%DstDay%echo %logDaysAgo%天前的日期是%logDstDate%::  ------------------- 删除文件夹 ------------------- echo 开始删除数据文件夹echo 开始删除数据文件夹 &gt;&gt; %logFile%setlocal enabledelayedexpansionfor /f &quot;delims=&quot; %%s in (&#39;dir /b /ad &quot;%bakTargetPath%&quot;&#39;) do (    set d=%%s    set dateParse=!d:~0,8!    echo 截取的日期为：!dateParse!    set stDate=%DstDate%    :: 如果该文件夹的日期小于该删除的备份日期，则删除该文件夹    set path=%bakTargetPath%!d!    echo 当前的路径!path!    if !dateParse! lss !stDate! call :DeleteDirectory !path!)echo 开始删除日志文件夹%logDir%echo 开始删除日志文件夹 &gt;&gt; %logFile%for /f &quot;delims=&quot; %%s in (&#39;dir /a-d /b &quot;%logDir%&quot;&#39;) do (    set d=%%s    set dateParse=!d:~0,8!    echo 截取的日期为：!dateParse!    set stDate=%logDstDate%    :: 如果该文件夹的日期小于该删除的备份日期，则删除该文件夹    set path=%logDir%!d!    echo 当前的路径!path!    if !dateParse! lss !stDate! call :DeleteFile !path!)endlocal::  --------------------------- 结束--------------------------- goto :eof:: 根据路径计算最后一个文件夹:LastFolder %1 folderNameSetlocal ENABLEDELAYEDEXPANSIONset string=%1::定义路径分隔符set ch=\set last=%string:~-1%if &quot;%last%&quot;==&quot;%ch%&quot; (set &quot;string=%string:~0,-1%&quot;)set str=%string%:nextif not &quot;%str%&quot;==&quot;&quot; (    if &quot;!str:~-1!&quot;==&quot;%ch%&quot; goto last    set rsString=!str:~-1!%rsString%     ::比较首字符是否为要求的字符，如果是则跳出循环    set &quot;str=%str:~0,-1%&quot;    goto next):last::将空格去掉set rsString=%rsString: =%echo 结果：%rsString%endlocal&amp;set %2=%rsString%&amp;goto :EOF:: 删除文件夹:DeleteDirectory %1setlocal ENABLEEXTENSIONSecho  ------------------ %1 ------------------rd /s /q %1echo  ------------------ 成功删除文件夹: %1 ------------------  &gt;&gt; %logFile%endlocal&amp;goto :EOF:: 删除文件:DeleteFile %1setlocal ENABLEEXTENSIONSecho  ------------------ %1 ------------------del /f /s /q /a %1echo  ------------------ 成功删除文件: %1 ------------------  &gt;&gt; %logFile%endlocal&amp;goto :EOF::以下是计算日期使用:DateToDays %yy% %mm% %dd% dayssetlocal ENABLEEXTENSIONSset yy=%1&amp;set mm=%2&amp;set dd=%3if 1%yy% LSS 200 if 1%yy% LSS 170 (set yy=20%yy%) else (set yy=19%yy%)set /a dd=100%dd%%%100,mm=100%mm%%%100set /a z=14-mm,z/=12,y=yy+4800-z,m=mm+12*z-3,j=153*m+2set /a j=j/5+dd+y*365+y/4-y/100+y/400-2472633endlocal&amp;set %4=%j%&amp;goto :EOF:DaysToDate %days% yy mm ddsetlocal ENABLEEXTENSIONSset /a a=%1+2472632,b=4*a+3,b/=146097,c=-b*146097,c/=4,c+=aset /a d=4*c+3,d/=1461,e=-1461*d,e/=4,e+=c,m=5*e+2,m/=153,dd=153*m+2,dd/=5set /a dd=-dd+e+1,mm=-m/10,mm*=12,mm+=m+3,yy=b*100+d-4800+m/10(if %mm% LSS 10 set mm=0%mm%)&amp;(if %dd% LSS 10 set dd=0%dd%)endlocal&amp;set %2=%yy%&amp;set %3=%mm%&amp;set %4=%dd%&amp;goto :EOF:: 结束goto使用： goto :eof</code></pre>]]></content>
    
    <summary type="html">
    
      通过windows的bat功能实现对文件夹的拷贝，并根据文件夹的日期计算是否要删除该文件夹
    
    </summary>
    
      <category term="windows" scheme="http://xiongyingqi.com/categories/windows/"/>
    
    
      <category term="bat" scheme="http://xiongyingqi.com/tags/bat/"/>
    
      <category term="windows" scheme="http://xiongyingqi.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Java String对象的经典问题</title>
    <link href="http://xiongyingqi.com/2013/12/30/2013-12-30-java-string/"/>
    <id>http://xiongyingqi.com/2013/12/30/2013-12-30-java-string/</id>
    <published>2013-12-30T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先来看一个例子，代码如下："><a href="#先来看一个例子，代码如下：" class="headerlink" title="先来看一个例子，代码如下："></a>先来看一个例子，代码如下：</h1><pre><code class="java">public class Test {      public static void main(String[] args) {          String str = &quot;abc&quot;;          String str1 = &quot;abc&quot;;          String str2 = new String(&quot;abc&quot;);          System.out.println(str == str1);          System.out.println(str1 == &quot;abc&quot;);          System.out.println(str2 == &quot;abc&quot;);          System.out.println(str1 == str2);          System.out.println(str1.equals(str2));          System.out.println(str1 == str2.intern());          System.out.println(str2 == str2.intern());          System.out.println(str1.hashCode() == str2.hashCode());      }  }</code></pre><p>如果您能对这8个输出结果直接判断出来，下面的分析就不用看了。但是我想还是有很多人对这个String对象这个问题只是表面的理解，下面就来分析一下Java语言String类和对象及其运行机制的问题。 </p><a id="more"></a><h1 id="做个基础的说明，堆-heap-内存和栈-Stack-内存的问题。"><a href="#做个基础的说明，堆-heap-内存和栈-Stack-内存的问题。" class="headerlink" title="做个基础的说明，堆(heap)内存和栈(Stack)内存的问题。"></a>做个基础的说明，堆(heap)内存和栈(Stack)内存的问题。</h1><p>堆和栈的数据结构这里就不解释了。Java语言使用内存的时候，栈内存主要保存以下内容：基本数据类型和对象的引用，而堆内存存储对象，栈内存的速度要快于堆内存。总结成一句话就是：引用在栈而对象在堆。</p><p>#Java中的比较有两种，是==和equals()方法，equals()是Object类的方法，定义在Object类中的equals()方法是如下实现的：</p><pre><code class="java">public boolean equals(Object obj){  return (this==obj);  }</code></pre><h1 id="String类重写了equals-方法，改变了这些类型对象相等的原则，即判断对象是否相等依据的原则为判断二者的内容是否相等。"><a href="#String类重写了equals-方法，改变了这些类型对象相等的原则，即判断对象是否相等依据的原则为判断二者的内容是否相等。" class="headerlink" title="String类重写了equals()方法，改变了这些类型对象相等的原则，即判断对象是否相等依据的原则为判断二者的内容是否相等。"></a>String类重写了equals()方法，改变了这些类型对象相等的原则，即判断对象是否相等依据的原则为判断二者的内容是否相等。</h1><p>了解以上内容后我们来说说String，String类的本质是字符数组char[]，其次String类是final的，是不可被继承的，这点可能被大多数人忽略，再次String是特殊的封装类型，使用String时可以直接赋值，也可以用new来创建对象，但是这二者的实现机制是不同的。</p><p><br>还有一个String池的概念，Java运行时维护一个String池，池中的String对象不可重复，没有创建，有则作罢。String池不属于堆和栈，而是属于常量池。</p><h1 id="下面分析上方代码的真正含义"><a href="#下面分析上方代码的真正含义" class="headerlink" title="下面分析上方代码的真正含义"></a>下面分析上方代码的真正含义</h1><pre><code class="java">String str = &quot;abc&quot;;  String str1= &quot;abc&quot;;</code></pre><ul><li>第一句的真正含义是在String池中创建一个对象”abc”，然后引用时str指向池中的对象”abc”。</li><li>第二句执行时，因为”abc”已经存在于String池了，所以不再创建，则str==str1返回true就明白了。</li><li>str1==”abc”肯定正确了，在String池中只有一个”abc”，而str和str1都指向池中的”abc”，就是这个道理。 </li></ul><pre><code class="java">String str2 = new String(&quot;abc&quot;);</code></pre><p>这个是Java SE的热点问题，众所周知，单独这句话创建了2个String对象，而基于上面两句，只在栈内存创建str2引用，在堆内存上创建一个String对象，内容是”abc”，而str2指向堆内存对象的首地址。</p><p><br>下面就是str2==”abc”的问题了，显然不对，”abc”是位于String池中的对象，而str2指向的是堆内存的String对象，==判断的是地址，肯定不等了。 </p><p><br>str1.equals(str2)，这个是对的，前面说过，String类的equals重写了Object类的equals()方法，实际就是判断内容是否相同了。</p><p><br>下面说下intern()方法，在JavaDoc文档中，这样描述了intern()方法：返回字符串对象的规范化表示形式。</p><p><br>怎么理解这句话？实际上过程是这样进行的：该方法现在String池中查找是否存在一个对象，存在了就返回String池中对象的引用。 </p><p><br>那么本例中String池存在”abc”，则调用intern()方法时返回的是池中”abc”对象引用，那么和str/str1都是等同的，和str2就不同了，因为str2指向的是堆内存。 </p><p><br>hashCode()方法是返回字符串内容的哈希码，既然内容相同，哈希码必然相同，那他们就相等了，这个容易理解。<br>再看下面的例子： </p><pre><code class="java">public class Test {      private static String str = &quot;abc&quot;;      public static void main(String[] args) {          String str1 = &quot;a&quot;;          String str2 = &quot;bc&quot;;          String combo = str1 + str2;          System.out.println(str == combo);          System.out.println(str == combo.intern());      }  }</code></pre><p>这个例子用来说明用+连接字符串时，实际上是在堆内容创建对象，那么combo指向的是堆内存存储”abc”字符串的空间首地址，显然str==combo是错误的，而str==combo.intern()是正确的，在String池中也存在”abc”，那就直接返回了，而str也是指向String池中的”abc”对象的。</p><p><br>此例说明任何重新修改String都是重新分配内存空间，这就使得String对象之间互不干扰。也就是String中的内容一旦生成不可改变，直至生成新的对象。 </p><p><br>同时问题也来了，使用+连接字符串每次都生成新的对象，而且是在堆内存上进行，而堆内存速度比较慢(相对而言)，那么再大量连接字符串时直接+是不可取的，当然需要一种效率高的方法。</p><p><br>Java提供的StringBuffer和StringBuilder就是解决这个问题的。区别是前者是线程安全的而后者是非线程安全的，StringBuilder在JDK1.5之后才有。不保证安全的StringBuilder有比StringBuffer更高的效率。 </p><p><br>自JDK1.5之后，Java虚拟机执行字符串的+操作时，内部实现也是StringBuilder，之前采用StringBuffer实现。 </p><p><br>欢迎交流，希望对使用者有用。</p>]]></content>
    
    <summary type="html">
    
      Java String的经典问题，面试笔试题的经典~
    
    </summary>
    
      <category term="java" scheme="http://xiongyingqi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://xiongyingqi.com/tags/java/"/>
    
      <category term="string" scheme="http://xiongyingqi.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>rmagick的安装</title>
    <link href="http://xiongyingqi.com/2013/12/28/2013-12-28-rmagick-install/"/>
    <id>http://xiongyingqi.com/2013/12/28/2013-12-28-rmagick-install/</id>
    <published>2013-12-28T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看到的基本上都是安装完ruby后再安装ImageMagick，然后再配置环境变量就可以了。。。<br><a id="more"></a><br>** 按照他们的安装方法经常出现缺失环境必备的文件等问题，我找了一个月左右终于找到了对应的版本：<br>railsinstaller-2.2.1.exe<br><br>ImageMagick-6.5.7-7-Q16-windows-dll.exe</p><p>** 我安装的文件：<a href="http://url.cn/VajhlO" target="_blank" rel="external">微云</a></p><p>** 然后配置四个环境变量就肯定可以安装<br>set DFImageMagick ImageMagick的安装目录<br><br>set PATH=%DFImageMagick%;%PATH%<br><br>set CPATH=%DFImageMagick%\include;%CPATH%<br><br>set LIBRARY_PATH=%DFImageMagick%\lib;%LIBRARY_PATH%<br></p>]]></content>
    
    <summary type="html">
    
      rmagick的安装方法，主要是ImageMagick与RailsInstaller版本不对
    
    </summary>
    
      <category term="jekyll" scheme="http://xiongyingqi.com/categories/jekyll/"/>
    
    
      <category term="rmagick" scheme="http://xiongyingqi.com/tags/rmagick/"/>
    
      <category term="jekyll" scheme="http://xiongyingqi.com/tags/jekyll/"/>
    
  </entry>
  
  <entry>
    <title>励志的鸡蛋</title>
    <link href="http://xiongyingqi.com/2013/12/28/2013-12-28-motivational-eggs/"/>
    <id>http://xiongyingqi.com/2013/12/28/2013-12-28-motivational-eggs/</id>
    <published>2013-12-28T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="励志的鸡蛋"><a href="#励志的鸡蛋" class="headerlink" title="励志的鸡蛋"></a>励志的鸡蛋</h1><a id="more"></a><p><img src="/images/post/motivational_eggs.jpg"></p>]]></content>
    
    <summary type="html">
    
      励志的鸡蛋，很有哲学哦~
    
    </summary>
    
      <category term="philosophy" scheme="http://xiongyingqi.com/categories/philosophy/"/>
    
    
      <category term="motivational" scheme="http://xiongyingqi.com/tags/motivational/"/>
    
  </entry>
  
  <entry>
    <title>BPMN 2.0之使用Event Base Gateway启动流程</title>
    <link href="http://xiongyingqi.com/2013/11/29/2013-11-29-BPMN-2-Event-Base-Gateway-start/"/>
    <id>http://xiongyingqi.com/2013/11/29/2013-11-29-BPMN-2-Event-Base-Gateway-start/</id>
    <published>2013-11-29T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇BPMN 2.0之Event Base Gateway（基于事件的网关）说了Event Base Gateway在流程流转中间的使用，Event Base Gateway的另一个用途是可以启动流程。<br><a id="more"></a></p><p>当Event Base Gateway被设置成启动流程时，它的图标会改变同时上游也不允许有流入的Sequence Flow。下面是个例子：<br><img src="/images/post/eventbase_gateway_start_process_1.png"></p><p>当上图的流程部署后，就会等待Email或电话请求。如果Email来了，就实例化一个流程实例，并从Task1开始执行。如果电话请求来了就再实例化一个流程实例从Task2开始执行。</p><p>缺省设置下，启动流程的Event Base Gateway是互斥的。可以用多个Start Event达到同样效果：<br><img src="/images/post/eventbase_gateway_start_process_2.png"></p><p>本人认为这种情况下，使用Start Event更直观也省画面空间。</p><p>另外我们也可以设置启动流程的Event Base Gateway是并行的，如下图（注意Event Base Gateway图标的变化）：<br><img src="/images/post/eventbase_gateway_start_process_1_same.png"></p><p>并行的Event Base Gateway在一个分支被激活并启动流程实例后，其他分支在启动的同一个流程实例中继续等待，如果在流程实例运行完成之前，其他分支也被激活，流程实例就多一条并行的流转分支。<br>这种情况真还一时半会还想不出对应的业务情景，很复杂？！</p>]]></content>
    
    <summary type="html">
    
      业务流程建模标记法（BPMN, Business Process Modeling Notation）是工作流中特定业务流程的图形化表示法。它由业务流程管理倡议组织（BPMI, Business Process Management Initiative）开发，该组织已于2005年与对象管理组织（OMG, Object Management Group）合并，从那时起，BPMN由OMG维护。BPMN当前版本为1.2，2009年1月发布，有重要修改的2.0版已经进入投票阶段。
    
    </summary>
    
      <category term="jbpm" scheme="http://xiongyingqi.com/categories/jbpm/"/>
    
    
      <category term="BPMN" scheme="http://xiongyingqi.com/tags/BPMN/"/>
    
      <category term="Gateway" scheme="http://xiongyingqi.com/tags/Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Git/SVN 常用命令笔记</title>
    <link href="http://xiongyingqi.com/2013/11/14/2013-11-14-github-notes/"/>
    <id>http://xiongyingqi.com/2013/11/14/2013-11-14-github-notes/</id>
    <published>2013-11-14T00:00:00.000Z</published>
    <updated>2017-11-02T08:39:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有更新 GitHub 了，以至于那些熟悉的命令也忘记了。今天更新一下，最基础的一些<br>命令，以备以后翻阅。<br>加之最近工作团队需要，经常使用 SVN ，所有将 SVN 的常用命令也记在后面。以备后用。<br><a id="more"></a></p><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><pre><code>git clone xx@xx:/xxx.git</code></pre><h4 id="更新源码"><a href="#更新源码" class="headerlink" title="更新源码"></a>更新源码</h4><pre><code>git pull</code></pre><h4 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h4><pre><code>git branch --查看分支git checkout -b name  --创建分支</code></pre><h4 id="更新相关"><a href="#更新相关" class="headerlink" title="更新相关"></a>更新相关</h4><pre><code>git add . -- 增加新的内容git commit -m &#39;修改的信息&#39; -- 提交的内容的信息git push -u origin master -- 将内容提交到主分支</code></pre><h4 id="Git状态"><a href="#Git状态" class="headerlink" title="Git状态"></a>Git状态</h4><pre><code>git status</code></pre><h4 id="查看提交内容的差异"><a href="#查看提交内容的差异" class="headerlink" title="查看提交内容的差异"></a>查看提交内容的差异</h4><pre><code>git log -p -1(1是最新的一条)</code></pre><h3 id="SVN相关"><a href="#SVN相关" class="headerlink" title="SVN相关"></a>SVN相关</h3><h4 id="将文件下载到本地"><a href="#将文件下载到本地" class="headerlink" title="将文件下载到本地"></a>将文件下载到本地</h4><pre><code>svn checkout path(服务器上的目录)//简写 svn co</code></pre><h4 id="往版本库添加新文件"><a href="#往版本库添加新文件" class="headerlink" title="往版本库添加新文件"></a>往版本库添加新文件</h4><pre><code>svn add file(文件名)</code></pre><h4 id="提交文件到版本库"><a href="#提交文件到版本库" class="headerlink" title="提交文件到版本库"></a>提交文件到版本库</h4><pre><code>svn commit -m &#39;logMassage&#39; (文件名)</code></pre><h4 id="加锁／解锁"><a href="#加锁／解锁" class="headerlink" title="加锁／解锁"></a>加锁／解锁</h4><pre><code>svn lock -m &#39;lockMessage&#39; (文件名)svn unlock path</code></pre><h4 id="更新到某个版本"><a href="#更新到某个版本" class="headerlink" title="更新到某个版本"></a>更新到某个版本</h4><pre><code>svn update -r m path -- m是版本号，path为文件名//简写 svn up</code></pre><h4 id="查看文件或者目录状态"><a href="#查看文件或者目录状态" class="headerlink" title="查看文件或者目录状态"></a>查看文件或者目录状态</h4><pre><code>svn status path</code></pre><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><pre><code>svn delete path -m &#39;delete message&#39;//简写 svn (del, remove, rm)</code></pre><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><pre><code>svn log path</code></pre><h4 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h4><pre><code>svn diff 文件名//简写 svn di</code></pre>]]></content>
    
    <summary type="html">
    
      很久没有更新 GitHub 了，以至于那些熟悉的命令也忘记了。今天更新一下，把最基础的内容记下。
    
    </summary>
    
      <category term="Git" scheme="http://xiongyingqi.com/categories/Git/"/>
    
    
      <category term="git" scheme="http://xiongyingqi.com/tags/git/"/>
    
      <category term="github" scheme="http://xiongyingqi.com/tags/github/"/>
    
  </entry>
  
</feed>
